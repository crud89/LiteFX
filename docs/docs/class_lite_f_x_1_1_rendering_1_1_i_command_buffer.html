<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LiteFX: LiteFX::Rendering::ICommandBuffer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="theme.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">LiteFX<span id="projectnumber">&#160;0.4.2.2025</span>
   </div>
   <div id="projectbrief">Computer Graphics Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('class_lite_f_x_1_1_rendering_1_1_i_command_buffer.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_lite_f_x_1_1_rendering_1_1_i_command_buffer-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">LiteFX::Rendering::ICommandBuffer Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>The interface for a command buffer.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="rendering__api_8hpp_source.html">rendering_api.hpp</a>&gt;</code></p>

<p>Inherits <a class="el" href="class_lite_f_x_1_1_shared_object.html">LiteFX::SharedObject</a>.</p>

<p>Inherited by <a class="el" href="class_lite_f_x_1_1_rendering_1_1_command_buffer.html">LiteFX::Rendering::CommandBuffer&lt; DirectX12CommandBuffer, IDirectX12Buffer, IDirectX12VertexBuffer, IDirectX12IndexBuffer, IDirectX12Image, DirectX12Barrier, DirectX12PipelineState, DirectX12BottomLevelAccelerationStructure, DirectX12TopLevelAccelerationStructure &gt;</a>, <a class="el" href="class_lite_f_x_1_1_rendering_1_1_command_buffer.html">LiteFX::Rendering::CommandBuffer&lt; VulkanCommandBuffer, IVulkanBuffer, IVulkanVertexBuffer, IVulkanIndexBuffer, IVulkanImage, VulkanBarrier, VulkanPipelineState, VulkanBottomLevelAccelerationStructure, VulkanTopLevelAccelerationStructure &gt;</a>, and <a class="el" href="class_lite_f_x_1_1_rendering_1_1_command_buffer.html">LiteFX::Rendering::CommandBuffer&lt; TCommandBuffer, TBuffer, TVertexBuffer, TIndexBuffer, TImage, TBarrier, TPipeline, TBLAS, TTLAS &gt;</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa975910adb2303cb8945469f5bbe5461" id="r_aa975910adb2303cb8945469f5bbe5461"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa975910adb2303cb8945469f5bbe5461">~ICommandBuffer</a> () noexcept override=default</td></tr>
<tr class="separator:aa975910adb2303cb8945469f5bbe5461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad08533dccdc780f870b9a5895aa3633b" id="r_ad08533dccdc780f870b9a5895aa3633b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad08533dccdc780f870b9a5895aa3633b">begin</a> () const =0</td></tr>
<tr class="memdesc:ad08533dccdc780f870b9a5895aa3633b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the command buffer into recording state, so that it can receive command that should be submitted to the parent <a class="el" href="class_lite_f_x_1_1_rendering_1_1_command_queue.html" title="Represents a command queue.">CommandQueue</a>.  <br /></td></tr>
<tr class="separator:ad08533dccdc780f870b9a5895aa3633b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a657800c43445c3ac118037d478a0d9d3" id="r_a657800c43445c3ac118037d478a0d9d3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a657800c43445c3ac118037d478a0d9d3">end</a> () const =0</td></tr>
<tr class="memdesc:a657800c43445c3ac118037d478a0d9d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ends recording commands on the command buffer.  <br /></td></tr>
<tr class="separator:a657800c43445c3ac118037d478a0d9d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5184ae021db9aa5324b0ca508164e717" id="r_a5184ae021db9aa5324b0ca508164e717"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5184ae021db9aa5324b0ca508164e717">isSecondary</a> () const noexcept=0</td></tr>
<tr class="memdesc:a5184ae021db9aa5324b0ca508164e717"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code>, if the command buffer is a secondary command buffer, or <code>false</code> otherwise.  <br /></td></tr>
<tr class="separator:a5184ae021db9aa5324b0ca508164e717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19a0010af97379721ddf59242481c15d" id="r_a19a0010af97379721ddf59242481c15d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a19a0010af97379721ddf59242481c15d">track</a> (<a class="el" href="namespace_lite_f_x.html#a58ddcdf7464eb219bb14d225153daa7f">SharedPtr</a>&lt; const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> &gt; buffer) const =0</td></tr>
<tr class="memdesc:a19a0010af97379721ddf59242481c15d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up tracking for a buffer, so that it will not be destroyed until the command buffer has been executed.  <br /></td></tr>
<tr class="separator:a19a0010af97379721ddf59242481c15d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa3cd495aff810b4b27e36e1798e0de3" id="r_afa3cd495aff810b4b27e36e1798e0de3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa3cd495aff810b4b27e36e1798e0de3">track</a> (<a class="el" href="namespace_lite_f_x.html#a58ddcdf7464eb219bb14d225153daa7f">SharedPtr</a>&lt; const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_image.html">IImage</a> &gt; image) const =0</td></tr>
<tr class="memdesc:afa3cd495aff810b4b27e36e1798e0de3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up tracking for an image, so that it will not be destroyed until the command buffer has been executed.  <br /></td></tr>
<tr class="separator:afa3cd495aff810b4b27e36e1798e0de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee6a49d3411bdd8767ab6a59828cb0f1" id="r_aee6a49d3411bdd8767ab6a59828cb0f1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee6a49d3411bdd8767ab6a59828cb0f1">track</a> (<a class="el" href="namespace_lite_f_x.html#a58ddcdf7464eb219bb14d225153daa7f">SharedPtr</a>&lt; const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_sampler.html">ISampler</a> &gt; sampler) const =0</td></tr>
<tr class="memdesc:aee6a49d3411bdd8767ab6a59828cb0f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up tracking for a sampler state, so that it will not be destroyed until the command buffer has been executed.  <br /></td></tr>
<tr class="separator:aee6a49d3411bdd8767ab6a59828cb0f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a866d6746ae7d5384a099852b5bafa527" id="r_a866d6746ae7d5384a099852b5bafa527"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_lite_f_x.html#a58ddcdf7464eb219bb14d225153daa7f">SharedPtr</a>&lt; const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_queue.html">ICommandQueue</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a866d6746ae7d5384a099852b5bafa527">queue</a> () const noexcept</td></tr>
<tr class="memdesc:a866d6746ae7d5384a099852b5bafa527"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a pointer to the command queue that this command buffer was allocated from or <code>nullptr</code>, if the queue has already been released.  <br /></td></tr>
<tr class="separator:a866d6746ae7d5384a099852b5bafa527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdc19aa9dc8455bcbcb42c8f28644bce" id="r_acdc19aa9dc8455bcbcb42c8f28644bce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_lite_f_x.html#a6daa7ddc3f560528522ba2849e09e3d3">UniquePtr</a>&lt; <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_barrier.html">IBarrier</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acdc19aa9dc8455bcbcb42c8f28644bce">makeBarrier</a> (<a class="el" href="namespace_lite_f_x_1_1_rendering.html#ad0c4e431db149130a77cfbbbe1aa8235">PipelineStage</a> syncBefore, <a class="el" href="namespace_lite_f_x_1_1_rendering.html#ad0c4e431db149130a77cfbbbe1aa8235">PipelineStage</a> syncAfter) const</td></tr>
<tr class="memdesc:acdc19aa9dc8455bcbcb42c8f28644bce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new barrier instance.  <br /></td></tr>
<tr class="separator:acdc19aa9dc8455bcbcb42c8f28644bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cd0bf45f3226dc39273c8f2bf738eac" id="r_a1cd0bf45f3226dc39273c8f2bf738eac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1cd0bf45f3226dc39273c8f2bf738eac">barrier</a> (const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_barrier.html">IBarrier</a> &amp;barrier) const noexcept</td></tr>
<tr class="memdesc:a1cd0bf45f3226dc39273c8f2bf738eac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the transitions that have been added to <em>barrier</em> .  <br /></td></tr>
<tr class="separator:a1cd0bf45f3226dc39273c8f2bf738eac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de8a81a5b0014f6ac40b3f05bdb673c" id="r_a3de8a81a5b0014f6ac40b3f05bdb673c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3de8a81a5b0014f6ac40b3f05bdb673c">transfer</a> (const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> &amp;source, const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> &amp;target, <a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a> sourceElement=0, <a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a> targetElement=0, <a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a> elements=1) const</td></tr>
<tr class="memdesc:a3de8a81a5b0014f6ac40b3f05bdb673c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a buffer-to-buffer transfer from <em>source</em>  to <em>target</em> .  <br /></td></tr>
<tr class="separator:a3de8a81a5b0014f6ac40b3f05bdb673c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8db0ed5d6cd741ad669fafc05a0e2037" id="r_a8db0ed5d6cd741ad669fafc05a0e2037"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8db0ed5d6cd741ad669fafc05a0e2037">transfer</a> (const <a class="el" href="namespace_lite_f_x.html#a58ddcdf7464eb219bb14d225153daa7f">SharedPtr</a>&lt; const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> &gt; &amp;source, const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> &amp;target, <a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a> sourceElement=0, <a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a> targetElement=0, <a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a> elements=1) const</td></tr>
<tr class="memdesc:a8db0ed5d6cd741ad669fafc05a0e2037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a buffer-to-buffer transfer from <em>source</em>  to <em>target</em> .  <br /></td></tr>
<tr class="separator:a8db0ed5d6cd741ad669fafc05a0e2037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d710981d0e77b8331ab09c291c00c5d" id="r_a9d710981d0e77b8331ab09c291c00c5d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9d710981d0e77b8331ab09c291c00c5d">transfer</a> (const void *const data, size_t size, const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> &amp;target, <a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a> targetElement=0, <a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a> elements=1) const</td></tr>
<tr class="memdesc:a9d710981d0e77b8331ab09c291c00c5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a buffer-to-buffer transfer from a temporary buffer into <em>target</em> .  <br /></td></tr>
<tr class="separator:a9d710981d0e77b8331ab09c291c00c5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb4741378af8d3e9033ef0ee2fb0474b" id="r_abb4741378af8d3e9033ef0ee2fb0474b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb4741378af8d3e9033ef0ee2fb0474b">transfer</a> (<a class="el" href="namespace_lite_f_x.html#aacf6de04faf43ec99887d011dd065ef4">Span</a>&lt; const void *const &gt; data, size_t elementSize, const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> &amp;target, <a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a> targetElement=0) const</td></tr>
<tr class="memdesc:abb4741378af8d3e9033ef0ee2fb0474b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a buffer-to-buffer transfer from a temporary buffer into <em>target</em> .  <br /></td></tr>
<tr class="separator:abb4741378af8d3e9033ef0ee2fb0474b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e46c51a81afdaf31dbaf367c6629c39" id="r_a7e46c51a81afdaf31dbaf367c6629c39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e46c51a81afdaf31dbaf367c6629c39">transfer</a> (const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> &amp;source, const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_image.html">IImage</a> &amp;target, <a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a> sourceElement=0, <a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a> firstSubresource=0, <a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a> elements=1) const</td></tr>
<tr class="memdesc:a7e46c51a81afdaf31dbaf367c6629c39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a buffer-to-image transfer from <em>source</em>  to <em>target</em> .  <br /></td></tr>
<tr class="separator:a7e46c51a81afdaf31dbaf367c6629c39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f7a480a90943026e7b9cf854489391f" id="r_a9f7a480a90943026e7b9cf854489391f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f7a480a90943026e7b9cf854489391f">transfer</a> (const <a class="el" href="namespace_lite_f_x.html#a58ddcdf7464eb219bb14d225153daa7f">SharedPtr</a>&lt; const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> &gt; &amp;source, const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_image.html">IImage</a> &amp;target, <a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a> sourceElement=0, <a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a> firstSubresource=0, <a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a> elements=1) const</td></tr>
<tr class="memdesc:a9f7a480a90943026e7b9cf854489391f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a buffer-to-image transfer from <em>source</em>  to <em>target</em> .  <br /></td></tr>
<tr class="separator:a9f7a480a90943026e7b9cf854489391f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37e992e52361628dfa46cc076892e9ad" id="r_a37e992e52361628dfa46cc076892e9ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a37e992e52361628dfa46cc076892e9ad">transfer</a> (const void *const data, size_t size, const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_image.html">IImage</a> &amp;target, <a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a> subresource=0) const</td></tr>
<tr class="memdesc:a37e992e52361628dfa46cc076892e9ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a buffer-to-buffer transfer from a temporary buffer into <em>target</em> .  <br /></td></tr>
<tr class="separator:a37e992e52361628dfa46cc076892e9ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a297fa30147364ad3e66e067b41d932cb" id="r_a297fa30147364ad3e66e067b41d932cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a297fa30147364ad3e66e067b41d932cb">transfer</a> (<a class="el" href="namespace_lite_f_x.html#aacf6de04faf43ec99887d011dd065ef4">Span</a>&lt; const void *const &gt; data, size_t elementSize, const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_image.html">IImage</a> &amp;target, <a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a> firstSubresource=0, <a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a> elements=1) const</td></tr>
<tr class="memdesc:a297fa30147364ad3e66e067b41d932cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a buffer-to-buffer transfer from a temporary buffer into <em>target</em> .  <br /></td></tr>
<tr class="separator:a297fa30147364ad3e66e067b41d932cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bfa216edf4732078742bd9db5536798" id="r_a6bfa216edf4732078742bd9db5536798"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6bfa216edf4732078742bd9db5536798">transfer</a> (const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_image.html">IImage</a> &amp;source, const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_image.html">IImage</a> &amp;target, <a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a> sourceSubresource=0, <a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a> targetSubresource=0, <a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a> subresources=1) const</td></tr>
<tr class="memdesc:a6bfa216edf4732078742bd9db5536798"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an image-to-image transfer from <em>source</em>  to <em>target</em> .  <br /></td></tr>
<tr class="separator:a6bfa216edf4732078742bd9db5536798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a708d9cfe459ba1edc1eadd389d0ab75e" id="r_a708d9cfe459ba1edc1eadd389d0ab75e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a708d9cfe459ba1edc1eadd389d0ab75e">transfer</a> (const <a class="el" href="namespace_lite_f_x.html#a58ddcdf7464eb219bb14d225153daa7f">SharedPtr</a>&lt; const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_image.html">IImage</a> &gt; &amp;source, const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_image.html">IImage</a> &amp;target, <a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a> sourceSubresource=0, <a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a> targetSubresource=0, <a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a> subresources=1) const</td></tr>
<tr class="memdesc:a708d9cfe459ba1edc1eadd389d0ab75e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an image-to-image transfer from <em>source</em>  to <em>target</em> .  <br /></td></tr>
<tr class="separator:a708d9cfe459ba1edc1eadd389d0ab75e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef34cddd04b35ce8ef644b56a1885b3b" id="r_aef34cddd04b35ce8ef644b56a1885b3b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef34cddd04b35ce8ef644b56a1885b3b">transfer</a> (const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_image.html">IImage</a> &amp;source, const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> &amp;target, <a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a> firstSubresource=0, <a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a> targetElement=0, <a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a> subresources=1) const</td></tr>
<tr class="memdesc:aef34cddd04b35ce8ef644b56a1885b3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an image-to-buffer transfer from <em>source</em>  to <em>target</em> .  <br /></td></tr>
<tr class="separator:aef34cddd04b35ce8ef644b56a1885b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6607074f4c6d56d2d3448ab48cd95522" id="r_a6607074f4c6d56d2d3448ab48cd95522"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6607074f4c6d56d2d3448ab48cd95522">transfer</a> (const <a class="el" href="namespace_lite_f_x.html#a58ddcdf7464eb219bb14d225153daa7f">SharedPtr</a>&lt; const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_image.html">IImage</a> &gt; &amp;source, const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> &amp;target, <a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a> firstSubresource=0, <a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a> targetElement=0, <a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a> subresources=1) const</td></tr>
<tr class="memdesc:a6607074f4c6d56d2d3448ab48cd95522"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an image-to-buffer transfer from <em>source</em>  to <em>target</em> .  <br /></td></tr>
<tr class="separator:a6607074f4c6d56d2d3448ab48cd95522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81dad499f968cc318887b5de2c88e237" id="r_a81dad499f968cc318887b5de2c88e237"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a81dad499f968cc318887b5de2c88e237">use</a> (const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_pipeline.html">IPipeline</a> &amp;pipeline) const noexcept</td></tr>
<tr class="memdesc:a81dad499f968cc318887b5de2c88e237"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the active pipeline state.  <br /></td></tr>
<tr class="separator:a81dad499f968cc318887b5de2c88e237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bd120d9d209a4ff7e92cf376069a44b" id="r_a2bd120d9d209a4ff7e92cf376069a44b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2bd120d9d209a4ff7e92cf376069a44b">bind</a> (const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_descriptor_set.html">IDescriptorSet</a> &amp;descriptorSet) const</td></tr>
<tr class="memdesc:a2bd120d9d209a4ff7e92cf376069a44b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds the provided descriptor to the last pipeline that was used by the command buffer.  <br /></td></tr>
<tr class="separator:a2bd120d9d209a4ff7e92cf376069a44b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5c6ea260785fd224023d571555795e0" id="r_ae5c6ea260785fd224023d571555795e0"><td class="memTemplParams" colspan="2">template&lt;typename TSelf , typename T &gt; <br />
requires std::derived_from&lt;T, <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_descriptor_set.html">IDescriptorSet</a>&gt;</td></tr>
<tr class="memitem:ae5c6ea260785fd224023d571555795e0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae5c6ea260785fd224023d571555795e0">bind</a> (this const TSelf &amp;self, std::initializer_list&lt; const T * &gt; descriptorSets)</td></tr>
<tr class="memdesc:ae5c6ea260785fd224023d571555795e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds an arbitrary input range of descriptor sets to the last pipeline that was used by the command buffer.  <br /></td></tr>
<tr class="separator:ae5c6ea260785fd224023d571555795e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bb27b7d6c03d6dd16f5567a802d5e0b" id="r_a6bb27b7d6c03d6dd16f5567a802d5e0b"><td class="memTemplParams" colspan="2">template&lt;typename TSelf &gt; <br />
requires std::derived_from&lt;std::remove_cv_t&lt;std::remove_pointer_t&lt;std::iter_value_t&lt;std::ranges::iterator_t&lt;std::remove_cv_t&lt;std::remove_reference_t&lt;decltype(descriptorSets)&gt;&gt;&gt;&gt;&gt;&gt;, <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_descriptor_set.html">IDescriptorSet</a>&gt;</td></tr>
<tr class="memitem:a6bb27b7d6c03d6dd16f5567a802d5e0b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6bb27b7d6c03d6dd16f5567a802d5e0b">bind</a> (this const TSelf &amp;self, std::ranges::input_range auto &amp;&amp;descriptorSets)</td></tr>
<tr class="memdesc:a6bb27b7d6c03d6dd16f5567a802d5e0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds an arbitrary input range of descriptor sets to the last pipeline that was used by the command buffer.  <br /></td></tr>
<tr class="separator:a6bb27b7d6c03d6dd16f5567a802d5e0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d7c1272ba2c598f7b990b42a47ad19c" id="r_a6d7c1272ba2c598f7b990b42a47ad19c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6d7c1272ba2c598f7b990b42a47ad19c">bind</a> (<a class="el" href="namespace_lite_f_x.html#aacf6de04faf43ec99887d011dd065ef4">Span</a>&lt; const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_descriptor_set.html">IDescriptorSet</a> * &gt; descriptorSets) const</td></tr>
<tr class="memdesc:a6d7c1272ba2c598f7b990b42a47ad19c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds an arbitrary input range of descriptor sets to the last pipeline that was used by the command buffer.  <br /></td></tr>
<tr class="separator:a6d7c1272ba2c598f7b990b42a47ad19c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae35239e8fd46d310d0ee4244b95e1761" id="r_ae35239e8fd46d310d0ee4244b95e1761"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae35239e8fd46d310d0ee4244b95e1761">bind</a> (const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_descriptor_set.html">IDescriptorSet</a> &amp;descriptorSet, const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_pipeline.html">IPipeline</a> &amp;pipeline) const</td></tr>
<tr class="memdesc:ae35239e8fd46d310d0ee4244b95e1761"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds the provided descriptor set to the provided pipeline.  <br /></td></tr>
<tr class="separator:ae35239e8fd46d310d0ee4244b95e1761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad56d3c6b7c1b88b0a6b9ead24e9a9158" id="r_ad56d3c6b7c1b88b0a6b9ead24e9a9158"><td class="memTemplParams" colspan="2">template&lt;typename TSelf , typename T &gt; </td></tr>
<tr class="memitem:ad56d3c6b7c1b88b0a6b9ead24e9a9158"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad56d3c6b7c1b88b0a6b9ead24e9a9158">bind</a> (this const TSelf &amp;self, std::initializer_list&lt; const T * &gt; descriptorSets, const typename TSelf::pipeline_type &amp;pipeline)</td></tr>
<tr class="memdesc:ad56d3c6b7c1b88b0a6b9ead24e9a9158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds an arbitrary input range of descriptor sets to the last pipeline that was used by the command buffer.  <br /></td></tr>
<tr class="separator:ad56d3c6b7c1b88b0a6b9ead24e9a9158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ea70ddcff4d21a5d4397fd9e5dccee0" id="r_a2ea70ddcff4d21a5d4397fd9e5dccee0"><td class="memTemplParams" colspan="2">template&lt;typename TSelf &gt; <br />
requires std::derived_from&lt;std::remove_cv_t&lt;std::remove_pointer_t&lt;std::iter_value_t&lt;std::ranges::iterator_t&lt;std::remove_cv_t&lt;std::remove_reference_t&lt;decltype(descriptorSets)&gt;&gt;&gt;&gt;&gt;&gt;, <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_descriptor_set.html">IDescriptorSet</a>&gt;</td></tr>
<tr class="memitem:a2ea70ddcff4d21a5d4397fd9e5dccee0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2ea70ddcff4d21a5d4397fd9e5dccee0">bind</a> (this const TSelf &amp;self, std::ranges::input_range auto &amp;&amp;descriptorSets, const typename TSelf::pipeline_type &amp;pipeline)</td></tr>
<tr class="memdesc:a2ea70ddcff4d21a5d4397fd9e5dccee0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds an arbitrary input range of descriptor sets to the provided pipeline.  <br /></td></tr>
<tr class="separator:a2ea70ddcff4d21a5d4397fd9e5dccee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc5f952b6fdb64f2cb531fe7c7524677" id="r_adc5f952b6fdb64f2cb531fe7c7524677"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adc5f952b6fdb64f2cb531fe7c7524677">bind</a> (<a class="el" href="namespace_lite_f_x.html#aacf6de04faf43ec99887d011dd065ef4">Span</a>&lt; const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_descriptor_set.html">IDescriptorSet</a> * &gt; descriptorSets, const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_pipeline.html">IPipeline</a> &amp;pipeline) const</td></tr>
<tr class="memdesc:adc5f952b6fdb64f2cb531fe7c7524677"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds an arbitrary input range of descriptor sets to the provided pipeline.  <br /></td></tr>
<tr class="separator:adc5f952b6fdb64f2cb531fe7c7524677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a555e04774c73b973396a31e1d96d73c4" id="r_a555e04774c73b973396a31e1d96d73c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a555e04774c73b973396a31e1d96d73c4">bind</a> (const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_vertex_buffer.html">IVertexBuffer</a> &amp;buffer) const</td></tr>
<tr class="memdesc:a555e04774c73b973396a31e1d96d73c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds a vertex buffer to the pipeline.  <br /></td></tr>
<tr class="separator:a555e04774c73b973396a31e1d96d73c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedaa8179e91cbd865fc70808205d2cdb" id="r_aedaa8179e91cbd865fc70808205d2cdb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aedaa8179e91cbd865fc70808205d2cdb">bind</a> (const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_index_buffer.html">IIndexBuffer</a> &amp;buffer) const</td></tr>
<tr class="memdesc:aedaa8179e91cbd865fc70808205d2cdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds a index buffer to the pipeline.  <br /></td></tr>
<tr class="separator:aedaa8179e91cbd865fc70808205d2cdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91ae552d6983c501f0c2e370f6e7c09e" id="r_a91ae552d6983c501f0c2e370f6e7c09e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a91ae552d6983c501f0c2e370f6e7c09e">dispatch</a> (const <a class="el" href="class_lite_f_x_1_1_math_1_1_vector3u.html">Vector3u</a> &amp;threadGroupCount) const noexcept=0</td></tr>
<tr class="memdesc:a91ae552d6983c501f0c2e370f6e7c09e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes a compute shader.  <br /></td></tr>
<tr class="separator:a91ae552d6983c501f0c2e370f6e7c09e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9c36f0909e825425c573eb10e96f039" id="r_aa9c36f0909e825425c573eb10e96f039"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa9c36f0909e825425c573eb10e96f039">dispatch</a> (<a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a> x, <a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a> y, <a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a> z) const noexcept</td></tr>
<tr class="memdesc:aa9c36f0909e825425c573eb10e96f039"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes a compute shader.  <br /></td></tr>
<tr class="separator:aa9c36f0909e825425c573eb10e96f039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaab09d4772229a48180989c1543c1b82" id="r_aaab09d4772229a48180989c1543c1b82"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaab09d4772229a48180989c1543c1b82">dispatchIndirect</a> (const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> &amp;batchBuffer, <a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a> batchCount, <a class="el" href="namespace_lite_f_x_1_1_math.html#a42c7bab2ce6b3575c6e1316cd87de457">UInt64</a> offset=0) const noexcept</td></tr>
<tr class="memdesc:aaab09d4772229a48180989c1543c1b82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes a set of indirect dispatches.  <br /></td></tr>
<tr class="separator:aaab09d4772229a48180989c1543c1b82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a0fa994f2355a8d5fb82c75515326e4" id="r_a4a0fa994f2355a8d5fb82c75515326e4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a0fa994f2355a8d5fb82c75515326e4">dispatchMesh</a> (const <a class="el" href="class_lite_f_x_1_1_math_1_1_vector3u.html">Vector3u</a> &amp;threadGroupCount) const noexcept=0</td></tr>
<tr class="memdesc:a4a0fa994f2355a8d5fb82c75515326e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes a mesh shader pipeline.  <br /></td></tr>
<tr class="separator:a4a0fa994f2355a8d5fb82c75515326e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ab33ae13478050d0b48beeb4124c523" id="r_a3ab33ae13478050d0b48beeb4124c523"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3ab33ae13478050d0b48beeb4124c523">dispatchMesh</a> (<a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a> x, <a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a> y, <a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a> z) const noexcept</td></tr>
<tr class="memdesc:a3ab33ae13478050d0b48beeb4124c523"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes a mesh shader pipeline.  <br /></td></tr>
<tr class="separator:a3ab33ae13478050d0b48beeb4124c523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7071a01a1f1f6ffd42bbed54aa8dd6a" id="r_ab7071a01a1f1f6ffd42bbed54aa8dd6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab7071a01a1f1f6ffd42bbed54aa8dd6a">dispatchMeshIndirect</a> (const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> &amp;batchBuffer, <a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a> batchCount, <a class="el" href="namespace_lite_f_x_1_1_math.html#a42c7bab2ce6b3575c6e1316cd87de457">UInt64</a> offset=0) const noexcept</td></tr>
<tr class="memdesc:ab7071a01a1f1f6ffd42bbed54aa8dd6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes a set of indirect mesh shader dispatches.  <br /></td></tr>
<tr class="separator:ab7071a01a1f1f6ffd42bbed54aa8dd6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afde5e1635528aefe732ea29c5b6f470a" id="r_afde5e1635528aefe732ea29c5b6f470a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afde5e1635528aefe732ea29c5b6f470a">dispatchMeshIndirect</a> (const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> &amp;batchBuffer, const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> &amp;countBuffer, <a class="el" href="namespace_lite_f_x_1_1_math.html#a42c7bab2ce6b3575c6e1316cd87de457">UInt64</a> offset=0, <a class="el" href="namespace_lite_f_x_1_1_math.html#a42c7bab2ce6b3575c6e1316cd87de457">UInt64</a> countOffset=0, <a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a> maxBatches=std::numeric_limits&lt; <a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a> &gt;::max()) const noexcept</td></tr>
<tr class="memdesc:afde5e1635528aefe732ea29c5b6f470a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes a set of indirect mesh shader dispatches.  <br /></td></tr>
<tr class="separator:afde5e1635528aefe732ea29c5b6f470a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d7e616cfa56a42ceb086246d32c2511" id="r_a0d7e616cfa56a42ceb086246d32c2511"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0d7e616cfa56a42ceb086246d32c2511">traceRays</a> (<a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a> width, <a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a> height, <a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a> depth, const <a class="el" href="struct_lite_f_x_1_1_rendering_1_1_shader_binding_table_offsets.html">ShaderBindingTableOffsets</a> &amp;offsets, const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> &amp;rayGenerationShaderBindingTable, const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> *missShaderBindingTable=nullptr, const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> *hitShaderBindingTable=nullptr, const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> *callableShaderBindingTable=nullptr) const noexcept</td></tr>
<tr class="memdesc:a0d7e616cfa56a42ceb086246d32c2511"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes a query on a ray-tracing pipeline.  <br /></td></tr>
<tr class="separator:a0d7e616cfa56a42ceb086246d32c2511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac0a545048689fe53304953614511425" id="r_aac0a545048689fe53304953614511425"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac0a545048689fe53304953614511425">traceRays</a> (const <a class="el" href="class_lite_f_x_1_1_math_1_1_vector3u.html">Vector3u</a> &amp;dimensions, const <a class="el" href="struct_lite_f_x_1_1_rendering_1_1_shader_binding_table_offsets.html">ShaderBindingTableOffsets</a> &amp;offsets, const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> &amp;rayGenerationShaderBindingTable, const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> *missShaderBindingTable=nullptr, const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> *hitShaderBindingTable=nullptr, const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> *callableShaderBindingTable=nullptr) const noexcept</td></tr>
<tr class="memdesc:aac0a545048689fe53304953614511425"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes a query on a ray-tracing pipeline.  <br /></td></tr>
<tr class="separator:aac0a545048689fe53304953614511425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5ce6b5c1b92773ad7ff3eeacf0382bd" id="r_af5ce6b5c1b92773ad7ff3eeacf0382bd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5ce6b5c1b92773ad7ff3eeacf0382bd">draw</a> (<a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a> vertices, <a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a> instances=1, <a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a> firstVertex=0, <a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a> firstInstance=0) const noexcept=0</td></tr>
<tr class="memdesc:af5ce6b5c1b92773ad7ff3eeacf0382bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a number of vertices from the currently bound vertex buffer.  <br /></td></tr>
<tr class="separator:af5ce6b5c1b92773ad7ff3eeacf0382bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac383ce8b1fb2a5340770cba0d8450a41" id="r_ac383ce8b1fb2a5340770cba0d8450a41"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac383ce8b1fb2a5340770cba0d8450a41">draw</a> (const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_vertex_buffer.html">IVertexBuffer</a> &amp;vertexBuffer, <a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a> instances=1, <a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a> firstVertex=0, <a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a> firstInstance=0) const</td></tr>
<tr class="memdesc:ac383ce8b1fb2a5340770cba0d8450a41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws all vertices from the vertex buffer provided in <em>vertexBuffer</em> .  <br /></td></tr>
<tr class="separator:ac383ce8b1fb2a5340770cba0d8450a41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc3ac58ad400c211e3fb84e168133761" id="r_acc3ac58ad400c211e3fb84e168133761"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acc3ac58ad400c211e3fb84e168133761">drawIndirect</a> (const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> &amp;batchBuffer, <a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a> batchCount, <a class="el" href="namespace_lite_f_x_1_1_math.html#a42c7bab2ce6b3575c6e1316cd87de457">UInt64</a> offset=0) const noexcept</td></tr>
<tr class="memdesc:acc3ac58ad400c211e3fb84e168133761"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes a set of indirect non-indexed draw calls.  <br /></td></tr>
<tr class="separator:acc3ac58ad400c211e3fb84e168133761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ba25d1a0a48576728be32cffaa97c03" id="r_a1ba25d1a0a48576728be32cffaa97c03"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ba25d1a0a48576728be32cffaa97c03">drawIndirect</a> (const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> &amp;batchBuffer, const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> &amp;countBuffer, <a class="el" href="namespace_lite_f_x_1_1_math.html#a42c7bab2ce6b3575c6e1316cd87de457">UInt64</a> offset=0, <a class="el" href="namespace_lite_f_x_1_1_math.html#a42c7bab2ce6b3575c6e1316cd87de457">UInt64</a> countOffset=0, <a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a> maxBatches=std::numeric_limits&lt; <a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a> &gt;::max()) const noexcept</td></tr>
<tr class="memdesc:a1ba25d1a0a48576728be32cffaa97c03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes a set of indirect non-indexed draw calls.  <br /></td></tr>
<tr class="separator:a1ba25d1a0a48576728be32cffaa97c03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ded2e94c2f6c5393619b56b0b175cd0" id="r_a3ded2e94c2f6c5393619b56b0b175cd0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3ded2e94c2f6c5393619b56b0b175cd0">drawIndexed</a> (<a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a> indices, <a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a> instances=1, <a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a> firstIndex=0, <a class="el" href="namespace_lite_f_x_1_1_math.html#af0b6b256c1127af430b6d0610e709f56">Int32</a> vertexOffset=0, <a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a> firstInstance=0) const noexcept=0</td></tr>
<tr class="memdesc:a3ded2e94c2f6c5393619b56b0b175cd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws the currently bound vertex buffer with a set of indices from the currently bound index buffer.  <br /></td></tr>
<tr class="separator:a3ded2e94c2f6c5393619b56b0b175cd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a398221b892ac67e183cac8f92033daa4" id="r_a398221b892ac67e183cac8f92033daa4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a398221b892ac67e183cac8f92033daa4">drawIndexed</a> (const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_index_buffer.html">IIndexBuffer</a> &amp;indexBuffer, <a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a> instances=1, <a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a> firstIndex=0, <a class="el" href="namespace_lite_f_x_1_1_math.html#af0b6b256c1127af430b6d0610e709f56">Int32</a> vertexOffset=0, <a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a> firstInstance=0) const</td></tr>
<tr class="memdesc:a398221b892ac67e183cac8f92033daa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws the currently bound vertex buffer using the index buffer provided in <em>indexBuffer</em> .  <br /></td></tr>
<tr class="separator:a398221b892ac67e183cac8f92033daa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6699ebad4ccb38e1647255830366c5ac" id="r_a6699ebad4ccb38e1647255830366c5ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6699ebad4ccb38e1647255830366c5ac">drawIndexed</a> (const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_vertex_buffer.html">IVertexBuffer</a> &amp;vertexBuffer, const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_index_buffer.html">IIndexBuffer</a> &amp;indexBuffer, <a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a> instances=1, <a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a> firstIndex=0, <a class="el" href="namespace_lite_f_x_1_1_math.html#af0b6b256c1127af430b6d0610e709f56">Int32</a> vertexOffset=0, <a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a> firstInstance=0) const</td></tr>
<tr class="memdesc:a6699ebad4ccb38e1647255830366c5ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws the vertex buffer provided by <em>vertexBuffer</em>  using the index buffer, provided by <em>indexBuffer</em> .  <br /></td></tr>
<tr class="separator:a6699ebad4ccb38e1647255830366c5ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a975ae3507a55c10f5f981e6edeb11222" id="r_a975ae3507a55c10f5f981e6edeb11222"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a975ae3507a55c10f5f981e6edeb11222">drawIndexedIndirect</a> (const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> &amp;batchBuffer, <a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a> batchCount, <a class="el" href="namespace_lite_f_x_1_1_math.html#a42c7bab2ce6b3575c6e1316cd87de457">UInt64</a> offset=0) const noexcept</td></tr>
<tr class="memdesc:a975ae3507a55c10f5f981e6edeb11222"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes a set of indirect indexed draw calls.  <br /></td></tr>
<tr class="separator:a975ae3507a55c10f5f981e6edeb11222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6a488ec2a952b72adb7ab6511d9791b" id="r_af6a488ec2a952b72adb7ab6511d9791b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af6a488ec2a952b72adb7ab6511d9791b">drawIndexedIndirect</a> (const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> &amp;batchBuffer, const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> &amp;countBuffer, <a class="el" href="namespace_lite_f_x_1_1_math.html#a42c7bab2ce6b3575c6e1316cd87de457">UInt64</a> offset=0, <a class="el" href="namespace_lite_f_x_1_1_math.html#a42c7bab2ce6b3575c6e1316cd87de457">UInt64</a> countOffset=0, <a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a> maxBatches=std::numeric_limits&lt; <a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a> &gt;::max()) const noexcept</td></tr>
<tr class="memdesc:af6a488ec2a952b72adb7ab6511d9791b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes a set of indirect indexed draw calls.  <br /></td></tr>
<tr class="separator:af6a488ec2a952b72adb7ab6511d9791b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cd9ebc23af8403b28676f460568b520" id="r_a2cd9ebc23af8403b28676f460568b520"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2cd9ebc23af8403b28676f460568b520">pushConstants</a> (const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_push_constants_layout.html">IPushConstantsLayout</a> &amp;layout, const void *const memory) const</td></tr>
<tr class="memdesc:a2cd9ebc23af8403b28676f460568b520"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes a block of memory into the push constants backing memory.  <br /></td></tr>
<tr class="separator:a2cd9ebc23af8403b28676f460568b520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad05010ea75366d7c5d81945967ec9c9" id="r_aad05010ea75366d7c5d81945967ec9c9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad05010ea75366d7c5d81945967ec9c9">setViewports</a> (<a class="el" href="namespace_lite_f_x.html#aacf6de04faf43ec99887d011dd065ef4">Span</a>&lt; const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_viewport.html">IViewport</a> * &gt; viewports) const =0</td></tr>
<tr class="memdesc:aad05010ea75366d7c5d81945967ec9c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the viewports used for the subsequent draw calls.  <br /></td></tr>
<tr class="separator:aad05010ea75366d7c5d81945967ec9c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a219e95355a72a766857ff844065d04a4" id="r_a219e95355a72a766857ff844065d04a4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a219e95355a72a766857ff844065d04a4">setViewports</a> (const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_viewport.html">IViewport</a> *viewport) const =0</td></tr>
<tr class="memdesc:a219e95355a72a766857ff844065d04a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the viewport used for the subsequent draw calls.  <br /></td></tr>
<tr class="separator:a219e95355a72a766857ff844065d04a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa216756129ae08431eeb61ee1f8bbebd" id="r_aa216756129ae08431eeb61ee1f8bbebd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa216756129ae08431eeb61ee1f8bbebd">setScissors</a> (<a class="el" href="namespace_lite_f_x.html#aacf6de04faf43ec99887d011dd065ef4">Span</a>&lt; const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_scissor.html">IScissor</a> * &gt; scissors) const =0</td></tr>
<tr class="memdesc:aa216756129ae08431eeb61ee1f8bbebd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the scissor rectangles used for the subsequent draw calls.  <br /></td></tr>
<tr class="separator:aa216756129ae08431eeb61ee1f8bbebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a687637f8cc8cf2353c6e8bfdc79b7d3c" id="r_a687637f8cc8cf2353c6e8bfdc79b7d3c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a687637f8cc8cf2353c6e8bfdc79b7d3c">setScissors</a> (const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_scissor.html">IScissor</a> *scissor) const =0</td></tr>
<tr class="memdesc:a687637f8cc8cf2353c6e8bfdc79b7d3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the scissor rectangle used for the subsequent draw calls.  <br /></td></tr>
<tr class="separator:a687637f8cc8cf2353c6e8bfdc79b7d3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15977513058f559f7fb09c7abbd4df17" id="r_a15977513058f559f7fb09c7abbd4df17"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a15977513058f559f7fb09c7abbd4df17">setBlendFactors</a> (const <a class="el" href="class_lite_f_x_1_1_math_1_1_vector4f.html">Vector4f</a> &amp;blendFactors) const noexcept=0</td></tr>
<tr class="memdesc:a15977513058f559f7fb09c7abbd4df17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the blend factors for the subsequent draw calls.  <br /></td></tr>
<tr class="separator:a15977513058f559f7fb09c7abbd4df17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae15e58df15cdb65c53b1305a6a202b47" id="r_ae15e58df15cdb65c53b1305a6a202b47"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae15e58df15cdb65c53b1305a6a202b47">setStencilRef</a> (<a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a> stencilRef) const noexcept=0</td></tr>
<tr class="memdesc:ae15e58df15cdb65c53b1305a6a202b47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the stencil reference for the subsequent draw calls.  <br /></td></tr>
<tr class="separator:ae15e58df15cdb65c53b1305a6a202b47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03a13eb3eefcdb8be47986354e3d69ac" id="r_a03a13eb3eefcdb8be47986354e3d69ac"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespace_lite_f_x_1_1_math.html#a42c7bab2ce6b3575c6e1316cd87de457">UInt64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a03a13eb3eefcdb8be47986354e3d69ac">submit</a> () const =0</td></tr>
<tr class="memdesc:a03a13eb3eefcdb8be47986354e3d69ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits the command buffer to parent command.  <br /></td></tr>
<tr class="separator:a03a13eb3eefcdb8be47986354e3d69ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53aeccd0d446ae06bc849b4dccee1c9c" id="r_a53aeccd0d446ae06bc849b4dccee1c9c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a53aeccd0d446ae06bc849b4dccee1c9c">writeTimingEvent</a> (const <a class="el" href="namespace_lite_f_x.html#a58ddcdf7464eb219bb14d225153daa7f">SharedPtr</a>&lt; const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_timing_event.html">TimingEvent</a> &gt; &amp;timingEvent) const =0</td></tr>
<tr class="memdesc:a53aeccd0d446ae06bc849b4dccee1c9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the current GPU time stamp value for the timing event.  <br /></td></tr>
<tr class="separator:a53aeccd0d446ae06bc849b4dccee1c9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c33e0960019a09d715c462006b2e01b" id="r_a5c33e0960019a09d715c462006b2e01b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c33e0960019a09d715c462006b2e01b">execute</a> (const <a class="el" href="namespace_lite_f_x.html#a58ddcdf7464eb219bb14d225153daa7f">SharedPtr</a>&lt; const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_buffer.html">ICommandBuffer</a> &gt; &amp;commandBuffer) const</td></tr>
<tr class="memdesc:a5c33e0960019a09d715c462006b2e01b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes a secondary command buffer/bundle.  <br /></td></tr>
<tr class="separator:a5c33e0960019a09d715c462006b2e01b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80c63a811f06993da32c5cb5688ced84" id="r_a80c63a811f06993da32c5cb5688ced84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a80c63a811f06993da32c5cb5688ced84">execute</a> (<a class="el" href="struct_lite_f_x_1_1_enumerable.html">Enumerable</a>&lt; <a class="el" href="namespace_lite_f_x.html#a58ddcdf7464eb219bb14d225153daa7f">SharedPtr</a>&lt; const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_buffer.html">ICommandBuffer</a> &gt; &gt; commandBuffers) const</td></tr>
<tr class="memdesc:a80c63a811f06993da32c5cb5688ced84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes a series of secondary command buffers/bundles.  <br /></td></tr>
<tr class="separator:a80c63a811f06993da32c5cb5688ced84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefb781fde72411588b7b94d10035d1ed" id="r_aefb781fde72411588b7b94d10035d1ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aefb781fde72411588b7b94d10035d1ed">buildAccelerationStructure</a> (<a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_bottom_level_acceleration_structure.html">IBottomLevelAccelerationStructure</a> &amp;blas, const <a class="el" href="namespace_lite_f_x.html#a58ddcdf7464eb219bb14d225153daa7f">SharedPtr</a>&lt; const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> &gt; &amp;scratchBuffer, const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> &amp;buffer, <a class="el" href="namespace_lite_f_x_1_1_math.html#a42c7bab2ce6b3575c6e1316cd87de457">UInt64</a> offset=0) const</td></tr>
<tr class="memdesc:aefb781fde72411588b7b94d10035d1ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a bottom-level acceleration structure.  <br /></td></tr>
<tr class="separator:aefb781fde72411588b7b94d10035d1ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3008bd86f3be59c8d51fd88ac853ca2c" id="r_a3008bd86f3be59c8d51fd88ac853ca2c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3008bd86f3be59c8d51fd88ac853ca2c">buildAccelerationStructure</a> (<a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_top_level_acceleration_structure.html">ITopLevelAccelerationStructure</a> &amp;tlas, const <a class="el" href="namespace_lite_f_x.html#a58ddcdf7464eb219bb14d225153daa7f">SharedPtr</a>&lt; const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> &gt; &amp;scratchBuffer, const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> &amp;buffer, <a class="el" href="namespace_lite_f_x_1_1_math.html#a42c7bab2ce6b3575c6e1316cd87de457">UInt64</a> offset=0) const</td></tr>
<tr class="memdesc:a3008bd86f3be59c8d51fd88ac853ca2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a top-level acceleration structure.  <br /></td></tr>
<tr class="separator:a3008bd86f3be59c8d51fd88ac853ca2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f97a142688028c51ae8f75536a6c454" id="r_a5f97a142688028c51ae8f75536a6c454"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f97a142688028c51ae8f75536a6c454">updateAccelerationStructure</a> (<a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_bottom_level_acceleration_structure.html">IBottomLevelAccelerationStructure</a> &amp;blas, const <a class="el" href="namespace_lite_f_x.html#a58ddcdf7464eb219bb14d225153daa7f">SharedPtr</a>&lt; const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> &gt; &amp;scratchBuffer, const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> &amp;buffer, <a class="el" href="namespace_lite_f_x_1_1_math.html#a42c7bab2ce6b3575c6e1316cd87de457">UInt64</a> offset=0) const</td></tr>
<tr class="memdesc:a5f97a142688028c51ae8f75536a6c454"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates a bottom-level acceleration structure.  <br /></td></tr>
<tr class="separator:a5f97a142688028c51ae8f75536a6c454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a174384b2e6bbba8a7c094369d816eabe" id="r_a174384b2e6bbba8a7c094369d816eabe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a174384b2e6bbba8a7c094369d816eabe">updateAccelerationStructure</a> (<a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_top_level_acceleration_structure.html">ITopLevelAccelerationStructure</a> &amp;tlas, const <a class="el" href="namespace_lite_f_x.html#a58ddcdf7464eb219bb14d225153daa7f">SharedPtr</a>&lt; const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> &gt; &amp;scratchBuffer, const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> &amp;buffer, <a class="el" href="namespace_lite_f_x_1_1_math.html#a42c7bab2ce6b3575c6e1316cd87de457">UInt64</a> offset=0) const</td></tr>
<tr class="memdesc:a174384b2e6bbba8a7c094369d816eabe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates a top-level acceleration structure.  <br /></td></tr>
<tr class="separator:a174384b2e6bbba8a7c094369d816eabe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9065701ec8ae4ba385f124374680fef8" id="r_a9065701ec8ae4ba385f124374680fef8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9065701ec8ae4ba385f124374680fef8">copyAccelerationStructure</a> (const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_bottom_level_acceleration_structure.html">IBottomLevelAccelerationStructure</a> &amp;from, const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_bottom_level_acceleration_structure.html">IBottomLevelAccelerationStructure</a> &amp;to, bool compress=false) const noexcept</td></tr>
<tr class="memdesc:a9065701ec8ae4ba385f124374680fef8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the acceleration structure <em>from</em>  into the acceleration structure <em>to</em> .  <br /></td></tr>
<tr class="separator:a9065701ec8ae4ba385f124374680fef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a473b279c0345a3fcbb77e1c97c6616c5" id="r_a473b279c0345a3fcbb77e1c97c6616c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a473b279c0345a3fcbb77e1c97c6616c5">copyAccelerationStructure</a> (const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_top_level_acceleration_structure.html">ITopLevelAccelerationStructure</a> &amp;from, const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_top_level_acceleration_structure.html">ITopLevelAccelerationStructure</a> &amp;to, bool compress=false) const noexcept</td></tr>
<tr class="memdesc:a473b279c0345a3fcbb77e1c97c6616c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the acceleration structure <em>from</em>  into the acceleration structure <em>to</em> .  <br /></td></tr>
<tr class="separator:a473b279c0345a3fcbb77e1c97c6616c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_lite_f_x_1_1_shared_object"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_class_lite_f_x_1_1_shared_object')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_lite_f_x_1_1_shared_object.html">LiteFX::SharedObject</a></td></tr>
<tr class="memitem:afa75ab8f78a411e8026ecb537e6003ed inherit pub_methods_class_lite_f_x_1_1_shared_object" id="r_afa75ab8f78a411e8026ecb537e6003ed"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lite_f_x_1_1_shared_object.html#afa75ab8f78a411e8026ecb537e6003ed">~SharedObject</a> () noexcept=default</td></tr>
<tr class="memdesc:afa75ab8f78a411e8026ecb537e6003ed inherit pub_methods_class_lite_f_x_1_1_shared_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the shared object.  <br /></td></tr>
<tr class="separator:afa75ab8f78a411e8026ecb537e6003ed inherit pub_methods_class_lite_f_x_1_1_shared_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade5d22f46286f19cdd18a6e37850f57e inherit pub_methods_class_lite_f_x_1_1_shared_object" id="r_ade5d22f46286f19cdd18a6e37850f57e"><td class="memTemplParams" colspan="2">template&lt;typename TSelf &gt; </td></tr>
<tr class="memitem:ade5d22f46286f19cdd18a6e37850f57e inherit pub_methods_class_lite_f_x_1_1_shared_object"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_lite_f_x_1_1_shared_object.html#ade5d22f46286f19cdd18a6e37850f57e">shared_from_this</a> (this TSelf &amp;&amp;self) noexcept</td></tr>
<tr class="memdesc:ade5d22f46286f19cdd18a6e37850f57e inherit pub_methods_class_lite_f_x_1_1_shared_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a shared pointer to the current object instance.  <br /></td></tr>
<tr class="separator:ade5d22f46286f19cdd18a6e37850f57e inherit pub_methods_class_lite_f_x_1_1_shared_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84f4b05ec46083b0605acb1213930aa5 inherit pub_methods_class_lite_f_x_1_1_shared_object" id="r_a84f4b05ec46083b0605acb1213930aa5"><td class="memTemplParams" colspan="2">template&lt;typename TSelf &gt; </td></tr>
<tr class="memitem:a84f4b05ec46083b0605acb1213930aa5 inherit pub_methods_class_lite_f_x_1_1_shared_object"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_lite_f_x_1_1_shared_object.html#a84f4b05ec46083b0605acb1213930aa5">weak_from_this</a> (this TSelf &amp;&amp;self) noexcept -&gt; <a class="el" href="namespace_lite_f_x.html#ae6e035fdf4b29e742139240ef9ea7869">WeakPtr</a>&lt; std::remove_reference_t&lt; TSelf &gt; &gt;</td></tr>
<tr class="memdesc:a84f4b05ec46083b0605acb1213930aa5 inherit pub_methods_class_lite_f_x_1_1_shared_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a weak pointer to the current object instance.  <br /></td></tr>
<tr class="separator:a84f4b05ec46083b0605acb1213930aa5 inherit pub_methods_class_lite_f_x_1_1_shared_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a1fc00c9ca56e62e74efcc3a39a17146b" id="r_a1fc00c9ca56e62e74efcc3a39a17146b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1fc00c9ca56e62e74efcc3a39a17146b">ICommandBuffer</a> () noexcept=default</td></tr>
<tr class="separator:a1fc00c9ca56e62e74efcc3a39a17146b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52c966b342269c643b8d82427ef0c787" id="r_a52c966b342269c643b8d82427ef0c787"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52c966b342269c643b8d82427ef0c787">ICommandBuffer</a> (<a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_buffer.html">ICommandBuffer</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="separator:a52c966b342269c643b8d82427ef0c787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e209b2512b1047da678143ad24e0e3f" id="r_a6e209b2512b1047da678143ad24e0e3f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e209b2512b1047da678143ad24e0e3f">ICommandBuffer</a> (const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_buffer.html">ICommandBuffer</a> &amp;)=default</td></tr>
<tr class="separator:a6e209b2512b1047da678143ad24e0e3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa985c87b29268d58c4287e71aa6c2fcf" id="r_aa985c87b29268d58c4287e71aa6c2fcf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_buffer.html">ICommandBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa985c87b29268d58c4287e71aa6c2fcf">operator=</a> (const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_buffer.html">ICommandBuffer</a> &amp;)=default</td></tr>
<tr class="separator:aa985c87b29268d58c4287e71aa6c2fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaac74bb678cf59017823028ca7ecfb62" id="r_aaac74bb678cf59017823028ca7ecfb62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_buffer.html">ICommandBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaac74bb678cf59017823028ca7ecfb62">operator=</a> (<a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_buffer.html">ICommandBuffer</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="separator:aaac74bb678cf59017823028ca7ecfb62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a684b278b20a31c08cff01fbbb56a3a7a" id="r_a684b278b20a31c08cff01fbbb56a3a7a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a684b278b20a31c08cff01fbbb56a3a7a">releaseSharedState</a> () const =0</td></tr>
<tr class="memdesc:a684b278b20a31c08cff01fbbb56a3a7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by the parent command queue to signal that the command buffer should release it's shared state.  <br /></td></tr>
<tr class="separator:a684b278b20a31c08cff01fbbb56a3a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_class_lite_f_x_1_1_shared_object"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_methods_class_lite_f_x_1_1_shared_object')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_lite_f_x_1_1_shared_object.html">LiteFX::SharedObject</a></td></tr>
<tr class="memitem:ac717edd284607580da2ee8a9b1e151f4 inherit pro_methods_class_lite_f_x_1_1_shared_object" id="r_ac717edd284607580da2ee8a9b1e151f4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lite_f_x_1_1_shared_object.html#ac717edd284607580da2ee8a9b1e151f4">SharedObject</a> () noexcept=default</td></tr>
<tr class="memdesc:ac717edd284607580da2ee8a9b1e151f4 inherit pro_methods_class_lite_f_x_1_1_shared_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new shared object.  <br /></td></tr>
<tr class="separator:ac717edd284607580da2ee8a9b1e151f4 inherit pro_methods_class_lite_f_x_1_1_shared_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad303ab7cdb4b41fd404a1a2bee11b759 inherit pro_methods_class_lite_f_x_1_1_shared_object" id="r_ad303ab7cdb4b41fd404a1a2bee11b759"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lite_f_x_1_1_shared_object.html#ad303ab7cdb4b41fd404a1a2bee11b759">SharedObject</a> (<a class="el" href="class_lite_f_x_1_1_shared_object.html">SharedObject</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="separator:ad303ab7cdb4b41fd404a1a2bee11b759 inherit pro_methods_class_lite_f_x_1_1_shared_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a414643fc0610998adc2588108ad54270 inherit pro_methods_class_lite_f_x_1_1_shared_object" id="r_a414643fc0610998adc2588108ad54270"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lite_f_x_1_1_shared_object.html#a414643fc0610998adc2588108ad54270">SharedObject</a> (const <a class="el" href="class_lite_f_x_1_1_shared_object.html">SharedObject</a> &amp;)=default</td></tr>
<tr class="separator:a414643fc0610998adc2588108ad54270 inherit pro_methods_class_lite_f_x_1_1_shared_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa787c88fc8797c0649e39a50212059b7 inherit pro_methods_class_lite_f_x_1_1_shared_object" id="r_aa787c88fc8797c0649e39a50212059b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_lite_f_x_1_1_shared_object.html">SharedObject</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lite_f_x_1_1_shared_object.html#aa787c88fc8797c0649e39a50212059b7">operator=</a> (<a class="el" href="class_lite_f_x_1_1_shared_object.html">SharedObject</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="separator:aa787c88fc8797c0649e39a50212059b7 inherit pro_methods_class_lite_f_x_1_1_shared_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e4efb35eb684f487c21db5e74667837 inherit pro_methods_class_lite_f_x_1_1_shared_object" id="r_a1e4efb35eb684f487c21db5e74667837"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_lite_f_x_1_1_shared_object.html">SharedObject</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lite_f_x_1_1_shared_object.html#a1e4efb35eb684f487c21db5e74667837">operator=</a> (const <a class="el" href="class_lite_f_x_1_1_shared_object.html">SharedObject</a> &amp;)=default</td></tr>
<tr class="separator:a1e4efb35eb684f487c21db5e74667837 inherit pro_methods_class_lite_f_x_1_1_shared_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a8e4925e00c4b5cfd5ef1730118c7cf7a" id="r_a8e4925e00c4b5cfd5ef1730118c7cf7a"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e4925e00c4b5cfd5ef1730118c7cf7a">ICommandQueue</a></td></tr>
<tr class="separator:a8e4925e00c4b5cfd5ef1730118c7cf7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_static_methods_class_lite_f_x_1_1_shared_object"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_static_methods_class_lite_f_x_1_1_shared_object')"><img src="closed.png" alt="-"/>&#160;Static Protected Member Functions inherited from <a class="el" href="class_lite_f_x_1_1_shared_object.html">LiteFX::SharedObject</a></td></tr>
<tr class="memitem:aad87cf7dce17bb1d48a65d8cc517e9e7 inherit pro_static_methods_class_lite_f_x_1_1_shared_object" id="r_aad87cf7dce17bb1d48a65d8cc517e9e7"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... TArgs&gt; </td></tr>
<tr class="memitem:aad87cf7dce17bb1d48a65d8cc517e9e7 inherit pro_static_methods_class_lite_f_x_1_1_shared_object"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_lite_f_x_1_1_shared_object.html#aad87cf7dce17bb1d48a65d8cc517e9e7">create</a> (TArgs &amp;&amp;... args) -&gt; <a class="el" href="namespace_lite_f_x.html#a58ddcdf7464eb219bb14d225153daa7f">SharedPtr</a>&lt; T &gt;</td></tr>
<tr class="memdesc:aad87cf7dce17bb1d48a65d8cc517e9e7 inherit pro_static_methods_class_lite_f_x_1_1_shared_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic factory method used to create instances of the shared object.  <br /></td></tr>
<tr class="separator:aad87cf7dce17bb1d48a65d8cc517e9e7 inherit pro_static_methods_class_lite_f_x_1_1_shared_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The interface for a command buffer. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a1fc00c9ca56e62e74efcc3a39a17146b" name="a1fc00c9ca56e62e74efcc3a39a17146b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fc00c9ca56e62e74efcc3a39a17146b">&#9670;&#160;</a></span>ICommandBuffer() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LiteFX::Rendering::ICommandBuffer::ICommandBuffer </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a52c966b342269c643b8d82427ef0c787" name="a52c966b342269c643b8d82427ef0c787"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52c966b342269c643b8d82427ef0c787">&#9670;&#160;</a></span>ICommandBuffer() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LiteFX::Rendering::ICommandBuffer::ICommandBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_buffer.html">ICommandBuffer</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6e209b2512b1047da678143ad24e0e3f" name="a6e209b2512b1047da678143ad24e0e3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e209b2512b1047da678143ad24e0e3f">&#9670;&#160;</a></span>ICommandBuffer() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LiteFX::Rendering::ICommandBuffer::ICommandBuffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_buffer.html">ICommandBuffer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa975910adb2303cb8945469f5bbe5461" name="aa975910adb2303cb8945469f5bbe5461"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa975910adb2303cb8945469f5bbe5461">&#9670;&#160;</a></span>~ICommandBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LiteFX::Rendering::ICommandBuffer::~ICommandBuffer </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1cd0bf45f3226dc39273c8f2bf738eac" name="a1cd0bf45f3226dc39273c8f2bf738eac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cd0bf45f3226dc39273c8f2bf738eac">&#9670;&#160;</a></span>barrier()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LiteFX::Rendering::ICommandBuffer::barrier </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_barrier.html">IBarrier</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>barrier</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes the transitions that have been added to <em>barrier</em> . </p>
<p>Calling this method will also update the resource states of each resource within the barrier. However, the actual state of the resource does not change until the barrier is executed on the command queue. Keep this in mind when inserting multiple barriers from different threads or in different command buffers, which may not be executed in order. You might have to manually synchronize barrier execution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">barrier</td><td>The barrier containing the transitions to perform.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad08533dccdc780f870b9a5895aa3633b" name="ad08533dccdc780f870b9a5895aa3633b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad08533dccdc780f870b9a5895aa3633b">&#9670;&#160;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void LiteFX::Rendering::ICommandBuffer::begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the command buffer into recording state, so that it can receive command that should be submitted to the parent <a class="el" href="class_lite_f_x_1_1_rendering_1_1_command_queue.html" title="Represents a command queue.">CommandQueue</a>. </p>
<p>Note that you have to wait for a command buffer to be executed on the parent <a class="el" href="class_lite_f_x_1_1_rendering_1_1_command_queue.html" title="Represents a command queue.">CommandQueue</a> before you can begin recording on it again. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_lite_f_x_1_1_runtime_exception.html" title="An exception that is thrown, if a requested operation could not be executed.">RuntimeException</a></td><td>Thrown, if the command buffer is already recording.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a657800c43445c3ac118037d478a0d9d3" title="Ends recording commands on the command buffer.">end</a></dd></dl>

<p>Implemented in <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_direct_x12_command_buffer.html#a52eb140093df379bc743c18025869ab2">LiteFX::Rendering::Backends::DirectX12CommandBuffer</a>, and <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_vulkan_command_buffer.html#a3d992e05fabf1c2791c8965c5faac382">LiteFX::Rendering::Backends::VulkanCommandBuffer</a>.</p>

</div>
</div>
<a id="a2bd120d9d209a4ff7e92cf376069a44b" name="a2bd120d9d209a4ff7e92cf376069a44b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bd120d9d209a4ff7e92cf376069a44b">&#9670;&#160;</a></span>bind() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LiteFX::Rendering::ICommandBuffer::bind </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_descriptor_set.html">IDescriptorSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>descriptorSet</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binds the provided descriptor to the last pipeline that was used by the command buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">descriptorSet</td><td>The descriptor set to bind.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_lite_f_x_1_1_runtime_exception.html" title="An exception that is thrown, if a requested operation could not be executed.">RuntimeException</a></td><td>Thrown, if no pipeline has been used before attempting to bind the descriptor set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a81dad499f968cc318887b5de2c88e237" title="Sets the active pipeline state.">use</a></dd></dl>

</div>
</div>
<a id="ae35239e8fd46d310d0ee4244b95e1761" name="ae35239e8fd46d310d0ee4244b95e1761"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae35239e8fd46d310d0ee4244b95e1761">&#9670;&#160;</a></span>bind() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LiteFX::Rendering::ICommandBuffer::bind </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_descriptor_set.html">IDescriptorSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>descriptorSet</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_pipeline.html">IPipeline</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pipeline</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binds the provided descriptor set to the provided pipeline. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">descriptorSet</td><td>The descriptor set to bind.</td></tr>
    <tr><td class="paramname">pipeline</td><td>The pipeline to bind the descriptor set to.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aedaa8179e91cbd865fc70808205d2cdb" name="aedaa8179e91cbd865fc70808205d2cdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedaa8179e91cbd865fc70808205d2cdb">&#9670;&#160;</a></span>bind() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LiteFX::Rendering::ICommandBuffer::bind </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_index_buffer.html">IIndexBuffer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binds a index buffer to the pipeline. </p>
<p>After binding the index buffer, the next call to <a class="el" href="#a3ded2e94c2f6c5393619b56b0b175cd0" title="Draws the currently bound vertex buffer with a set of indices from the currently bound index buffer.">drawIndexed</a> will read from it, until another index buffer is bound. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The index buffer to bind to the pipeline.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_lite_f_x_1_1_rendering_1_1_index_buffer.html" title="Describes an index buffer.">IndexBuffer</a>, <a class="el" href="#a3ded2e94c2f6c5393619b56b0b175cd0" title="Draws the currently bound vertex buffer with a set of indices from the currently bound index buffer.">drawIndexed</a></dd></dl>

</div>
</div>
<a id="a555e04774c73b973396a31e1d96d73c4" name="a555e04774c73b973396a31e1d96d73c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a555e04774c73b973396a31e1d96d73c4">&#9670;&#160;</a></span>bind() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LiteFX::Rendering::ICommandBuffer::bind </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_vertex_buffer.html">IVertexBuffer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binds a vertex buffer to the pipeline. </p>
<p>After binding the vertex buffer, the next call to <a class="el" href="#af5ce6b5c1b92773ad7ff3eeacf0382bd" title="Draws a number of vertices from the currently bound vertex buffer.">draw</a> or <a class="el" href="#a3ded2e94c2f6c5393619b56b0b175cd0" title="Draws the currently bound vertex buffer with a set of indices from the currently bound index buffer.">drawIndexed</a> will read from it, until another vertex buffer is bound. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The vertex buffer to bind to the pipeline.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_lite_f_x_1_1_rendering_1_1_vertex_buffer.html" title="Describes a vertex buffer.">VertexBuffer</a>, <a class="el" href="#af5ce6b5c1b92773ad7ff3eeacf0382bd" title="Draws a number of vertices from the currently bound vertex buffer.">draw</a>, <a class="el" href="#a3ded2e94c2f6c5393619b56b0b175cd0" title="Draws the currently bound vertex buffer with a set of indices from the currently bound index buffer.">drawIndexed</a></dd></dl>

</div>
</div>
<a id="a6d7c1272ba2c598f7b990b42a47ad19c" name="a6d7c1272ba2c598f7b990b42a47ad19c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d7c1272ba2c598f7b990b42a47ad19c">&#9670;&#160;</a></span>bind() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LiteFX::Rendering::ICommandBuffer::bind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x.html#aacf6de04faf43ec99887d011dd065ef4">Span</a>&lt; const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_descriptor_set.html">IDescriptorSet</a> * &gt;</td>          <td class="paramname"><span class="paramname"><em>descriptorSets</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binds an arbitrary input range of descriptor sets to the last pipeline that was used by the command buffer. </p>
<p>Note that if an element of <em>descriptorSets</em>  is <code>nullptr</code>, it will be ignored. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">descriptorSets</td><td>The pointers to the descriptor sets to bind.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adc5f952b6fdb64f2cb531fe7c7524677" name="adc5f952b6fdb64f2cb531fe7c7524677"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc5f952b6fdb64f2cb531fe7c7524677">&#9670;&#160;</a></span>bind() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LiteFX::Rendering::ICommandBuffer::bind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x.html#aacf6de04faf43ec99887d011dd065ef4">Span</a>&lt; const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_descriptor_set.html">IDescriptorSet</a> * &gt;</td>          <td class="paramname"><span class="paramname"><em>descriptorSets</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_pipeline.html">IPipeline</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pipeline</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binds an arbitrary input range of descriptor sets to the provided pipeline. </p>
<p>Note that if an element of <em>descriptorSets</em>  is <code>nullptr</code>, it will be ignored. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">descriptorSets</td><td>The pointers to the descriptor sets to bind.</td></tr>
    <tr><td class="paramname">pipeline</td><td>The pipeline to bind the descriptor set to.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae5c6ea260785fd224023d571555795e0" name="ae5c6ea260785fd224023d571555795e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5c6ea260785fd224023d571555795e0">&#9670;&#160;</a></span>bind() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSelf , typename T &gt; <br />
requires std::derived_from&lt;T, <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_descriptor_set.html">IDescriptorSet</a>&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LiteFX::Rendering::ICommandBuffer::bind </td>
          <td>(</td>
          <td class="paramtype">this const TSelf &amp;</td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; const T * &gt;</td>          <td class="paramname"><span class="paramname"><em>descriptorSets</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binds an arbitrary input range of descriptor sets to the last pipeline that was used by the command buffer. </p>
<p>Note that if an element of <em>descriptorSets</em>  is <code>nullptr</code>, it will be ignored. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the descriptor sets.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">descriptorSets</td><td>The pointers to the descriptor sets to bind.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_lite_f_x_1_1_runtime_exception.html" title="An exception that is thrown, if a requested operation could not be executed.">RuntimeException</a></td><td>Thrown, if no pipeline has been used before attempting to bind the descriptor set.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad56d3c6b7c1b88b0a6b9ead24e9a9158" name="ad56d3c6b7c1b88b0a6b9ead24e9a9158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad56d3c6b7c1b88b0a6b9ead24e9a9158">&#9670;&#160;</a></span>bind() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSelf , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LiteFX::Rendering::ICommandBuffer::bind </td>
          <td>(</td>
          <td class="paramtype">this const TSelf &amp;</td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; const T * &gt;</td>          <td class="paramname"><span class="paramname"><em>descriptorSets</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename TSelf::pipeline_type &amp;</td>          <td class="paramname"><span class="paramname"><em>pipeline</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binds an arbitrary input range of descriptor sets to the last pipeline that was used by the command buffer. </p>
<p>Note that if an element of <em>descriptorSets</em>  is <code>nullptr</code>, it will be ignored. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the descriptor sets.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">descriptorSets</td><td>The pointers to the descriptor sets to bind.</td></tr>
    <tr><td class="paramname">pipeline</td><td>The pipeline to bind the descriptor set to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_lite_f_x_1_1_runtime_exception.html" title="An exception that is thrown, if a requested operation could not be executed.">RuntimeException</a></td><td>Thrown, if no pipeline has been used before attempting to bind the descriptor set.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6bb27b7d6c03d6dd16f5567a802d5e0b" name="a6bb27b7d6c03d6dd16f5567a802d5e0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bb27b7d6c03d6dd16f5567a802d5e0b">&#9670;&#160;</a></span>bind() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSelf &gt; <br />
requires std::derived_from&lt;std::remove_cv_t&lt;std::remove_pointer_t&lt;std::iter_value_t&lt;std::ranges::iterator_t&lt;std::remove_cv_t&lt;std::remove_reference_t&lt;decltype(descriptorSets)&gt;&gt;&gt;&gt;&gt;&gt;, <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_descriptor_set.html">IDescriptorSet</a>&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LiteFX::Rendering::ICommandBuffer::bind </td>
          <td>(</td>
          <td class="paramtype">this const TSelf &amp;</td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ranges::input_range auto &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>descriptorSets</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binds an arbitrary input range of descriptor sets to the last pipeline that was used by the command buffer. </p>
<p>Note that if an element of <em>descriptorSets</em>  is <code>nullptr</code>, it will be ignored. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">descriptorSets</td><td>The pointers to the descriptor sets to bind.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_lite_f_x_1_1_runtime_exception.html" title="An exception that is thrown, if a requested operation could not be executed.">RuntimeException</a></td><td>Thrown, if no pipeline has been used before attempting to bind the descriptor set.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2ea70ddcff4d21a5d4397fd9e5dccee0" name="a2ea70ddcff4d21a5d4397fd9e5dccee0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ea70ddcff4d21a5d4397fd9e5dccee0">&#9670;&#160;</a></span>bind() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSelf &gt; <br />
requires std::derived_from&lt;std::remove_cv_t&lt;std::remove_pointer_t&lt;std::iter_value_t&lt;std::ranges::iterator_t&lt;std::remove_cv_t&lt;std::remove_reference_t&lt;decltype(descriptorSets)&gt;&gt;&gt;&gt;&gt;&gt;, <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_descriptor_set.html">IDescriptorSet</a>&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LiteFX::Rendering::ICommandBuffer::bind </td>
          <td>(</td>
          <td class="paramtype">this const TSelf &amp;</td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ranges::input_range auto &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>descriptorSets</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename TSelf::pipeline_type &amp;</td>          <td class="paramname"><span class="paramname"><em>pipeline</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binds an arbitrary input range of descriptor sets to the provided pipeline. </p>
<p>Note that if an element of <em>descriptorSets</em>  is <code>nullptr</code>, it will be ignored. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">descriptorSets</td><td>The pointers to the descriptor sets to bind.</td></tr>
    <tr><td class="paramname">pipeline</td><td>The pipeline to bind the descriptor set to.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aefb781fde72411588b7b94d10035d1ed" name="aefb781fde72411588b7b94d10035d1ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefb781fde72411588b7b94d10035d1ed">&#9670;&#160;</a></span>buildAccelerationStructure() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LiteFX::Rendering::ICommandBuffer::buildAccelerationStructure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_bottom_level_acceleration_structure.html">IBottomLevelAccelerationStructure</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>blas</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_lite_f_x.html#a58ddcdf7464eb219bb14d225153daa7f">SharedPtr</a>&lt; const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>scratchBuffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#a42c7bab2ce6b3575c6e1316cd87de457">UInt64</a></td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Builds a bottom-level acceleration structure. </p>
<p>This method is only supported if the GraphicsDeviceFeature::RayTracing feature is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blas</td><td>The bottom-level acceleration structure to build.</td></tr>
    <tr><td class="paramname">scratchBuffer</td><td>The scratch buffer to use for building the acceleration structure.</td></tr>
    <tr><td class="paramname">buffer</td><td>The buffer that contains the acceleration structure after the build.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset into <em>buffer</em>  at which the acceleration structure gets stored after the build.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_lite_f_x_1_1_argument_not_initialized_exception.html" title="An exception that is thrown, if a provided non-optional argument was not initialized.">ArgumentNotInitializedException</a></td><td>Thrown, if the provided <em>scratchBuffer</em>  is not initialized.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_acceleration_structure.html#aa41a80d20632be5288d3a1d69f291562" title="Performs a complete build of the acceleration structure.">IAccelerationStructure::build</a></dd></dl>

</div>
</div>
<a id="a3008bd86f3be59c8d51fd88ac853ca2c" name="a3008bd86f3be59c8d51fd88ac853ca2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3008bd86f3be59c8d51fd88ac853ca2c">&#9670;&#160;</a></span>buildAccelerationStructure() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LiteFX::Rendering::ICommandBuffer::buildAccelerationStructure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_top_level_acceleration_structure.html">ITopLevelAccelerationStructure</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>tlas</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_lite_f_x.html#a58ddcdf7464eb219bb14d225153daa7f">SharedPtr</a>&lt; const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>scratchBuffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#a42c7bab2ce6b3575c6e1316cd87de457">UInt64</a></td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Builds a top-level acceleration structure. </p>
<p>This method is only supported if the GraphicsDeviceFeature::RayTracing feature is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tlas</td><td>The top-level acceleration structure to build.</td></tr>
    <tr><td class="paramname">scratchBuffer</td><td>The scratch buffer to use for building the acceleration structure.</td></tr>
    <tr><td class="paramname">buffer</td><td>The buffer that contains the acceleration structure after the build.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset into <em>buffer</em>  at which the acceleration structure gets stored after the build.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_lite_f_x_1_1_argument_not_initialized_exception.html" title="An exception that is thrown, if a provided non-optional argument was not initialized.">ArgumentNotInitializedException</a></td><td>Thrown, if the provided <em>scratchBuffer</em>  is not initialized.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_acceleration_structure.html#aa41a80d20632be5288d3a1d69f291562" title="Performs a complete build of the acceleration structure.">IAccelerationStructure::build</a></dd></dl>

</div>
</div>
<a id="a9065701ec8ae4ba385f124374680fef8" name="a9065701ec8ae4ba385f124374680fef8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9065701ec8ae4ba385f124374680fef8">&#9670;&#160;</a></span>copyAccelerationStructure() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LiteFX::Rendering::ICommandBuffer::copyAccelerationStructure </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_bottom_level_acceleration_structure.html">IBottomLevelAccelerationStructure</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_bottom_level_acceleration_structure.html">IBottomLevelAccelerationStructure</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>to</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>compress</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the acceleration structure <em>from</em>  into the acceleration structure <em>to</em> . </p>
<p>Prefer calling <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_bottom_level_acceleration_structure.html#a27e8bf728275bed3ed0cc20842f53094" title="Copies the acceleration structure into the acceleration structure provided by destination .">IBottomLevelAccelerationStructure::copy</a> over directly issuing copy commands on a command buffer, as this will make sure that the destination buffer will be properly allocated and contains enough memory to store the copy. Only issue copies on the command buffer directly, if you want to retain the destination buffer and know for certain, that it contains a sufficient amount of memory.</p>
<p>This method is only supported if the GraphicsDeviceFeature::RayTracing feature is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>The source acceleration structure to copy from.</td></tr>
    <tr><td class="paramname">to</td><td>The destination acceleration structure to copy to.</td></tr>
    <tr><td class="paramname">compress</td><td>If set to <code>true</code>, the acceleration structure will be compressed.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a473b279c0345a3fcbb77e1c97c6616c5" name="a473b279c0345a3fcbb77e1c97c6616c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a473b279c0345a3fcbb77e1c97c6616c5">&#9670;&#160;</a></span>copyAccelerationStructure() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LiteFX::Rendering::ICommandBuffer::copyAccelerationStructure </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_top_level_acceleration_structure.html">ITopLevelAccelerationStructure</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_top_level_acceleration_structure.html">ITopLevelAccelerationStructure</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>to</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>compress</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the acceleration structure <em>from</em>  into the acceleration structure <em>to</em> . </p>
<p>Prefer calling <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_top_level_acceleration_structure.html#a6bca05f1b7f295663eceafc5b54a9f9a" title="Copies the acceleration structure into the acceleration structure provided by destination .">ITopLevelAccelerationStructure::copy</a> over directly issuing copy commands on a command buffer, as this will make sure that the destination buffer will be properly allocated and contains enough memory to store the copy. Only issue copies on the command buffer directly, if you want to retain the destination buffer and know for certain, that it contains a sufficient amount of memory.</p>
<p>This method is only supported if the GraphicsDeviceFeature::RayTracing feature is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>The source acceleration structure to copy from.</td></tr>
    <tr><td class="paramname">to</td><td>The destination acceleration structure to copy to.</td></tr>
    <tr><td class="paramname">compress</td><td>If set to <code>true</code>, the acceleration structure will be compressed.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a91ae552d6983c501f0c2e370f6e7c09e" name="a91ae552d6983c501f0c2e370f6e7c09e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91ae552d6983c501f0c2e370f6e7c09e">&#9670;&#160;</a></span>dispatch() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void LiteFX::Rendering::ICommandBuffer::dispatch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_math_1_1_vector3u.html">Vector3u</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>threadGroupCount</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes a compute shader. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">threadCount</td><td>The number of thread groups per dimension.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#aaab09d4772229a48180989c1543c1b82" title="Executes a set of indirect dispatches.">dispatchIndirect</a></dd></dl>

<p>Implemented in <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_direct_x12_command_buffer.html#a5a595df75528e08d2771a1a14fd08375">LiteFX::Rendering::Backends::DirectX12CommandBuffer</a>, <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_vulkan_command_buffer.html#acf9b4596f4bc07fd90ce01e6b1585b5e">LiteFX::Rendering::Backends::VulkanCommandBuffer</a>, <a class="el" href="class_lite_f_x_1_1_rendering_1_1_command_buffer.html#a91ae552d6983c501f0c2e370f6e7c09e">LiteFX::Rendering::CommandBuffer&lt; TCommandBuffer, TBuffer, TVertexBuffer, TIndexBuffer, TImage, TBarrier, TPipeline, TBLAS, TTLAS &gt;</a>, <a class="el" href="class_lite_f_x_1_1_rendering_1_1_command_buffer.html#a91ae552d6983c501f0c2e370f6e7c09e">LiteFX::Rendering::CommandBuffer&lt; DirectX12CommandBuffer, IDirectX12Buffer, IDirectX12VertexBuffer, IDirectX12IndexBuffer, IDirectX12Image, DirectX12Barrier, DirectX12PipelineState, DirectX12BottomLevelAccelerationStructure, DirectX12TopLevelAccelerationStructure &gt;</a>, and <a class="el" href="class_lite_f_x_1_1_rendering_1_1_command_buffer.html#a91ae552d6983c501f0c2e370f6e7c09e">LiteFX::Rendering::CommandBuffer&lt; VulkanCommandBuffer, IVulkanBuffer, IVulkanVertexBuffer, IVulkanIndexBuffer, IVulkanImage, VulkanBarrier, VulkanPipelineState, VulkanBottomLevelAccelerationStructure, VulkanTopLevelAccelerationStructure &gt;</a>.</p>

</div>
</div>
<a id="aa9c36f0909e825425c573eb10e96f039" name="aa9c36f0909e825425c573eb10e96f039"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9c36f0909e825425c573eb10e96f039">&#9670;&#160;</a></span>dispatch() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LiteFX::Rendering::ICommandBuffer::dispatch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a></td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a></td>          <td class="paramname"><span class="paramname"><em>z</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes a compute shader. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The number of thread groups along the x dimension.</td></tr>
    <tr><td class="paramname">y</td><td>The number of thread groups along the y dimension.</td></tr>
    <tr><td class="paramname">z</td><td>The number of thread groups along the z dimension.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaab09d4772229a48180989c1543c1b82" name="aaab09d4772229a48180989c1543c1b82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaab09d4772229a48180989c1543c1b82">&#9670;&#160;</a></span>dispatchIndirect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LiteFX::Rendering::ICommandBuffer::dispatchIndirect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>batchBuffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a></td>          <td class="paramname"><span class="paramname"><em>batchCount</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#a42c7bab2ce6b3575c6e1316cd87de457">UInt64</a></td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes a set of indirect dispatches. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">batchBuffer</td><td>The buffer that contains the batches.</td></tr>
    <tr><td class="paramname">batchCount</td><td>The number of batches in the buffer to execute.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset (in bytes) to the first batch in the <em>batchBuffer</em> .</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a91ae552d6983c501f0c2e370f6e7c09e" title="Executes a compute shader.">dispatch</a></dd></dl>

</div>
</div>
<a id="a4a0fa994f2355a8d5fb82c75515326e4" name="a4a0fa994f2355a8d5fb82c75515326e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a0fa994f2355a8d5fb82c75515326e4">&#9670;&#160;</a></span>dispatchMesh() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void LiteFX::Rendering::ICommandBuffer::dispatchMesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_math_1_1_vector3u.html">Vector3u</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>threadGroupCount</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes a mesh shader pipeline. </p>
<p>This method is only supported if the GraphicsDeviceFeature::MeshShaders feature is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">threadCount</td><td>The number of thread groups per dimension.</td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_direct_x12_command_buffer.html#ac65866d9f87f57e463ff26cd51b2445d">LiteFX::Rendering::Backends::DirectX12CommandBuffer</a>, <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_vulkan_command_buffer.html#aee6bf7201e1e2f34710910fb8752f396">LiteFX::Rendering::Backends::VulkanCommandBuffer</a>, <a class="el" href="class_lite_f_x_1_1_rendering_1_1_command_buffer.html#a4a0fa994f2355a8d5fb82c75515326e4">LiteFX::Rendering::CommandBuffer&lt; TCommandBuffer, TBuffer, TVertexBuffer, TIndexBuffer, TImage, TBarrier, TPipeline, TBLAS, TTLAS &gt;</a>, <a class="el" href="class_lite_f_x_1_1_rendering_1_1_command_buffer.html#a4a0fa994f2355a8d5fb82c75515326e4">LiteFX::Rendering::CommandBuffer&lt; DirectX12CommandBuffer, IDirectX12Buffer, IDirectX12VertexBuffer, IDirectX12IndexBuffer, IDirectX12Image, DirectX12Barrier, DirectX12PipelineState, DirectX12BottomLevelAccelerationStructure, DirectX12TopLevelAccelerationStructure &gt;</a>, and <a class="el" href="class_lite_f_x_1_1_rendering_1_1_command_buffer.html#a4a0fa994f2355a8d5fb82c75515326e4">LiteFX::Rendering::CommandBuffer&lt; VulkanCommandBuffer, IVulkanBuffer, IVulkanVertexBuffer, IVulkanIndexBuffer, IVulkanImage, VulkanBarrier, VulkanPipelineState, VulkanBottomLevelAccelerationStructure, VulkanTopLevelAccelerationStructure &gt;</a>.</p>

</div>
</div>
<a id="a3ab33ae13478050d0b48beeb4124c523" name="a3ab33ae13478050d0b48beeb4124c523"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ab33ae13478050d0b48beeb4124c523">&#9670;&#160;</a></span>dispatchMesh() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LiteFX::Rendering::ICommandBuffer::dispatchMesh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a></td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a></td>          <td class="paramname"><span class="paramname"><em>z</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes a mesh shader pipeline. </p>
<p>This method is only supported if the GraphicsDeviceFeature::MeshShaders feature is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The number of thread groups along the x dimension.</td></tr>
    <tr><td class="paramname">y</td><td>The number of thread groups along the y dimension.</td></tr>
    <tr><td class="paramname">z</td><td>The number of thread groups along the z dimension.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afde5e1635528aefe732ea29c5b6f470a" name="afde5e1635528aefe732ea29c5b6f470a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afde5e1635528aefe732ea29c5b6f470a">&#9670;&#160;</a></span>dispatchMeshIndirect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LiteFX::Rendering::ICommandBuffer::dispatchMeshIndirect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>batchBuffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>countBuffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#a42c7bab2ce6b3575c6e1316cd87de457">UInt64</a></td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#a42c7bab2ce6b3575c6e1316cd87de457">UInt64</a></td>          <td class="paramname"><span class="paramname"><em>countOffset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a></td>          <td class="paramname"><span class="paramname"><em>maxBatches</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::numeric_limits&lt;<a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a>&gt;::max()</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes a set of indirect mesh shader dispatches. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">batchBuffer</td><td>The buffer that contains the batches.</td></tr>
    <tr><td class="paramname">countBuffer</td><td>The buffer that contains the number of batches to execute.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset (in bytes) to the first batch in the <em>batchBuffer</em> .</td></tr>
    <tr><td class="paramname">countOffset</td><td>The offset (in bytes) to the number of batches in the <em>countBuffer</em> .</td></tr>
    <tr><td class="paramname">maxBatches</td><td>The maximum number of batches executed, even if there are more batches in <em>countBuffer</em> .</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a91ae552d6983c501f0c2e370f6e7c09e" title="Executes a compute shader.">dispatch</a></dd></dl>

</div>
</div>
<a id="ab7071a01a1f1f6ffd42bbed54aa8dd6a" name="ab7071a01a1f1f6ffd42bbed54aa8dd6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7071a01a1f1f6ffd42bbed54aa8dd6a">&#9670;&#160;</a></span>dispatchMeshIndirect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LiteFX::Rendering::ICommandBuffer::dispatchMeshIndirect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>batchBuffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a></td>          <td class="paramname"><span class="paramname"><em>batchCount</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#a42c7bab2ce6b3575c6e1316cd87de457">UInt64</a></td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes a set of indirect mesh shader dispatches. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">batchBuffer</td><td>The buffer that contains the batches.</td></tr>
    <tr><td class="paramname">batchCount</td><td>The number of batches in the buffer to execute.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset (in bytes) to the first batch in the <em>batchBuffer</em> .</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a4a0fa994f2355a8d5fb82c75515326e4" title="Executes a mesh shader pipeline.">dispatchMesh</a></dd></dl>

</div>
</div>
<a id="ac383ce8b1fb2a5340770cba0d8450a41" name="ac383ce8b1fb2a5340770cba0d8450a41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac383ce8b1fb2a5340770cba0d8450a41">&#9670;&#160;</a></span>draw() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LiteFX::Rendering::ICommandBuffer::draw </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_vertex_buffer.html">IVertexBuffer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vertexBuffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a></td>          <td class="paramname"><span class="paramname"><em>instances</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a></td>          <td class="paramname"><span class="paramname"><em>firstVertex</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a></td>          <td class="paramname"><span class="paramname"><em>firstInstance</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws all vertices from the vertex buffer provided in <em>vertexBuffer</em> . </p>
<p>This helper method binds the vertex buffer and issues a draw command for all vertices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertexBuffer</td><td>The vertex buffer to draw from.</td></tr>
    <tr><td class="paramname">instances</td><td>The number of instances to draw.</td></tr>
    <tr><td class="paramname">firstVertex</td><td>The index of the first vertex to start drawing from.</td></tr>
    <tr><td class="paramname">firstInstance</td><td>The index of the first instance to draw.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af5ce6b5c1b92773ad7ff3eeacf0382bd" name="af5ce6b5c1b92773ad7ff3eeacf0382bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5ce6b5c1b92773ad7ff3eeacf0382bd">&#9670;&#160;</a></span>draw() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void LiteFX::Rendering::ICommandBuffer::draw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a></td>          <td class="paramname"><span class="paramname"><em>vertices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a></td>          <td class="paramname"><span class="paramname"><em>instances</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a></td>          <td class="paramname"><span class="paramname"><em>firstVertex</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a></td>          <td class="paramname"><span class="paramname"><em>firstInstance</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws a number of vertices from the currently bound vertex buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>The number of vertices to draw.</td></tr>
    <tr><td class="paramname">instances</td><td>The number of instances to draw.</td></tr>
    <tr><td class="paramname">firstVertex</td><td>The index of the first vertex to start drawing from.</td></tr>
    <tr><td class="paramname">firstInstance</td><td>The index of the first instance to draw.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#acc3ac58ad400c211e3fb84e168133761" title="Executes a set of indirect non-indexed draw calls.">drawIndirect</a></dd></dl>

<p>Implemented in <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_direct_x12_command_buffer.html#a400147fc7567a8b6e053661d7bbed93d">LiteFX::Rendering::Backends::DirectX12CommandBuffer</a>, <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_vulkan_command_buffer.html#a1a8a15d40cf145e9cad411495520ba8e">LiteFX::Rendering::Backends::VulkanCommandBuffer</a>, <a class="el" href="class_lite_f_x_1_1_rendering_1_1_command_buffer.html#af5ce6b5c1b92773ad7ff3eeacf0382bd">LiteFX::Rendering::CommandBuffer&lt; TCommandBuffer, TBuffer, TVertexBuffer, TIndexBuffer, TImage, TBarrier, TPipeline, TBLAS, TTLAS &gt;</a>, <a class="el" href="class_lite_f_x_1_1_rendering_1_1_command_buffer.html#af5ce6b5c1b92773ad7ff3eeacf0382bd">LiteFX::Rendering::CommandBuffer&lt; DirectX12CommandBuffer, IDirectX12Buffer, IDirectX12VertexBuffer, IDirectX12IndexBuffer, IDirectX12Image, DirectX12Barrier, DirectX12PipelineState, DirectX12BottomLevelAccelerationStructure, DirectX12TopLevelAccelerationStructure &gt;</a>, and <a class="el" href="class_lite_f_x_1_1_rendering_1_1_command_buffer.html#af5ce6b5c1b92773ad7ff3eeacf0382bd">LiteFX::Rendering::CommandBuffer&lt; VulkanCommandBuffer, IVulkanBuffer, IVulkanVertexBuffer, IVulkanIndexBuffer, IVulkanImage, VulkanBarrier, VulkanPipelineState, VulkanBottomLevelAccelerationStructure, VulkanTopLevelAccelerationStructure &gt;</a>.</p>

</div>
</div>
<a id="a398221b892ac67e183cac8f92033daa4" name="a398221b892ac67e183cac8f92033daa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a398221b892ac67e183cac8f92033daa4">&#9670;&#160;</a></span>drawIndexed() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LiteFX::Rendering::ICommandBuffer::drawIndexed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_index_buffer.html">IIndexBuffer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>indexBuffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a></td>          <td class="paramname"><span class="paramname"><em>instances</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a></td>          <td class="paramname"><span class="paramname"><em>firstIndex</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#af0b6b256c1127af430b6d0610e709f56">Int32</a></td>          <td class="paramname"><span class="paramname"><em>vertexOffset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a></td>          <td class="paramname"><span class="paramname"><em>firstInstance</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws the currently bound vertex buffer using the index buffer provided in <em>indexBuffer</em> . </p>
<p>This helper method binds the index buffer and issues a draw command for all indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indexBuffer</td><td>The index buffer to draw with.</td></tr>
    <tr><td class="paramname">instances</td><td>The number of instances to draw.</td></tr>
    <tr><td class="paramname">firstIndex</td><td>The index of the first element of the index buffer to start drawing from.</td></tr>
    <tr><td class="paramname">vertexOffset</td><td>The offset added to each index to find the corresponding vertex.</td></tr>
    <tr><td class="paramname">firstInstance</td><td>The index of the first instance to draw.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6699ebad4ccb38e1647255830366c5ac" name="a6699ebad4ccb38e1647255830366c5ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6699ebad4ccb38e1647255830366c5ac">&#9670;&#160;</a></span>drawIndexed() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LiteFX::Rendering::ICommandBuffer::drawIndexed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_vertex_buffer.html">IVertexBuffer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vertexBuffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_index_buffer.html">IIndexBuffer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>indexBuffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a></td>          <td class="paramname"><span class="paramname"><em>instances</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a></td>          <td class="paramname"><span class="paramname"><em>firstIndex</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#af0b6b256c1127af430b6d0610e709f56">Int32</a></td>          <td class="paramname"><span class="paramname"><em>vertexOffset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a></td>          <td class="paramname"><span class="paramname"><em>firstInstance</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws the vertex buffer provided by <em>vertexBuffer</em>  using the index buffer, provided by <em>indexBuffer</em> . </p>
<p>This helper method binds the provided vertex and index buffers and issues a draw command for all indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertexBuffer</td><td>The vertex buffer to draw from.</td></tr>
    <tr><td class="paramname">indexBuffer</td><td>The index buffer to draw with.</td></tr>
    <tr><td class="paramname">instances</td><td>The number of instances to draw.</td></tr>
    <tr><td class="paramname">firstIndex</td><td>The index of the first element of the index buffer to start drawing from.</td></tr>
    <tr><td class="paramname">vertexOffset</td><td>The offset added to each index to find the corresponding vertex.</td></tr>
    <tr><td class="paramname">firstInstance</td><td>The index of the first instance to draw.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3ded2e94c2f6c5393619b56b0b175cd0" name="a3ded2e94c2f6c5393619b56b0b175cd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ded2e94c2f6c5393619b56b0b175cd0">&#9670;&#160;</a></span>drawIndexed() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void LiteFX::Rendering::ICommandBuffer::drawIndexed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a></td>          <td class="paramname"><span class="paramname"><em>indices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a></td>          <td class="paramname"><span class="paramname"><em>instances</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a></td>          <td class="paramname"><span class="paramname"><em>firstIndex</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#af0b6b256c1127af430b6d0610e709f56">Int32</a></td>          <td class="paramname"><span class="paramname"><em>vertexOffset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a></td>          <td class="paramname"><span class="paramname"><em>firstInstance</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws the currently bound vertex buffer with a set of indices from the currently bound index buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>The number of indices to draw.</td></tr>
    <tr><td class="paramname">instances</td><td>The number of instances to draw.</td></tr>
    <tr><td class="paramname">firstIndex</td><td>The index of the first element of the index buffer to start drawing from.</td></tr>
    <tr><td class="paramname">vertexOffset</td><td>The offset added to each index to find the corresponding vertex.</td></tr>
    <tr><td class="paramname">firstInstance</td><td>The index of the first instance to draw.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a975ae3507a55c10f5f981e6edeb11222" title="Executes a set of indirect indexed draw calls.">drawIndexedIndirect</a></dd></dl>

<p>Implemented in <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_direct_x12_command_buffer.html#aed5f11f82980fdbace380d44a450d5d9">LiteFX::Rendering::Backends::DirectX12CommandBuffer</a>, <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_vulkan_command_buffer.html#a635d45abfd3decde249ab2a4f6da8bc2">LiteFX::Rendering::Backends::VulkanCommandBuffer</a>, <a class="el" href="class_lite_f_x_1_1_rendering_1_1_command_buffer.html#a3ded2e94c2f6c5393619b56b0b175cd0">LiteFX::Rendering::CommandBuffer&lt; TCommandBuffer, TBuffer, TVertexBuffer, TIndexBuffer, TImage, TBarrier, TPipeline, TBLAS, TTLAS &gt;</a>, <a class="el" href="class_lite_f_x_1_1_rendering_1_1_command_buffer.html#a3ded2e94c2f6c5393619b56b0b175cd0">LiteFX::Rendering::CommandBuffer&lt; DirectX12CommandBuffer, IDirectX12Buffer, IDirectX12VertexBuffer, IDirectX12IndexBuffer, IDirectX12Image, DirectX12Barrier, DirectX12PipelineState, DirectX12BottomLevelAccelerationStructure, DirectX12TopLevelAccelerationStructure &gt;</a>, and <a class="el" href="class_lite_f_x_1_1_rendering_1_1_command_buffer.html#a3ded2e94c2f6c5393619b56b0b175cd0">LiteFX::Rendering::CommandBuffer&lt; VulkanCommandBuffer, IVulkanBuffer, IVulkanVertexBuffer, IVulkanIndexBuffer, IVulkanImage, VulkanBarrier, VulkanPipelineState, VulkanBottomLevelAccelerationStructure, VulkanTopLevelAccelerationStructure &gt;</a>.</p>

</div>
</div>
<a id="af6a488ec2a952b72adb7ab6511d9791b" name="af6a488ec2a952b72adb7ab6511d9791b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6a488ec2a952b72adb7ab6511d9791b">&#9670;&#160;</a></span>drawIndexedIndirect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LiteFX::Rendering::ICommandBuffer::drawIndexedIndirect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>batchBuffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>countBuffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#a42c7bab2ce6b3575c6e1316cd87de457">UInt64</a></td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#a42c7bab2ce6b3575c6e1316cd87de457">UInt64</a></td>          <td class="paramname"><span class="paramname"><em>countOffset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a></td>          <td class="paramname"><span class="paramname"><em>maxBatches</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::numeric_limits&lt;<a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a>&gt;::max()</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes a set of indirect indexed draw calls. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">batchBuffer</td><td>The buffer that contains the batches.</td></tr>
    <tr><td class="paramname">countBuffer</td><td>The buffer that contains the number of batches to execute.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset (in bytes) to the first batch in the <em>batchBuffer</em> .</td></tr>
    <tr><td class="paramname">countOffset</td><td>The offset (in bytes) to the number of batches in the <em>countBuffer</em> .</td></tr>
    <tr><td class="paramname">maxBatches</td><td>The maximum number of batches executed, even if there are more batches in <em>countBuffer</em> .</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3ded2e94c2f6c5393619b56b0b175cd0" title="Draws the currently bound vertex buffer with a set of indices from the currently bound index buffer.">drawIndexed</a></dd></dl>

</div>
</div>
<a id="a975ae3507a55c10f5f981e6edeb11222" name="a975ae3507a55c10f5f981e6edeb11222"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a975ae3507a55c10f5f981e6edeb11222">&#9670;&#160;</a></span>drawIndexedIndirect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LiteFX::Rendering::ICommandBuffer::drawIndexedIndirect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>batchBuffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a></td>          <td class="paramname"><span class="paramname"><em>batchCount</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#a42c7bab2ce6b3575c6e1316cd87de457">UInt64</a></td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes a set of indirect indexed draw calls. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">batchBuffer</td><td>The buffer that contains the batches.</td></tr>
    <tr><td class="paramname">batchCount</td><td>The number of batches in the buffer to execute.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset (in bytes) to the first batch in the <em>batchBuffer</em> .</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3ded2e94c2f6c5393619b56b0b175cd0" title="Draws the currently bound vertex buffer with a set of indices from the currently bound index buffer.">drawIndexed</a></dd></dl>

</div>
</div>
<a id="a1ba25d1a0a48576728be32cffaa97c03" name="a1ba25d1a0a48576728be32cffaa97c03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ba25d1a0a48576728be32cffaa97c03">&#9670;&#160;</a></span>drawIndirect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LiteFX::Rendering::ICommandBuffer::drawIndirect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>batchBuffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>countBuffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#a42c7bab2ce6b3575c6e1316cd87de457">UInt64</a></td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#a42c7bab2ce6b3575c6e1316cd87de457">UInt64</a></td>          <td class="paramname"><span class="paramname"><em>countOffset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a></td>          <td class="paramname"><span class="paramname"><em>maxBatches</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::numeric_limits&lt;<a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a>&gt;::max()</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes a set of indirect non-indexed draw calls. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">batchBuffer</td><td>The buffer that contains the batches.</td></tr>
    <tr><td class="paramname">countBuffer</td><td>The buffer that contains the number of batches to execute.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset (in bytes) to the first batch in the <em>batchBuffer</em> .</td></tr>
    <tr><td class="paramname">countOffset</td><td>The offset (in bytes) to the number of batches in the <em>countBuffer</em> .</td></tr>
    <tr><td class="paramname">maxBatches</td><td>The maximum number of batches executed, even if there are more batches in <em>countBuffer</em> .</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#af5ce6b5c1b92773ad7ff3eeacf0382bd" title="Draws a number of vertices from the currently bound vertex buffer.">draw</a></dd></dl>

</div>
</div>
<a id="acc3ac58ad400c211e3fb84e168133761" name="acc3ac58ad400c211e3fb84e168133761"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc3ac58ad400c211e3fb84e168133761">&#9670;&#160;</a></span>drawIndirect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LiteFX::Rendering::ICommandBuffer::drawIndirect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>batchBuffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a></td>          <td class="paramname"><span class="paramname"><em>batchCount</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#a42c7bab2ce6b3575c6e1316cd87de457">UInt64</a></td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes a set of indirect non-indexed draw calls. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">batchBuffer</td><td>The buffer that contains the batches.</td></tr>
    <tr><td class="paramname">batchCount</td><td>The number of batches in the buffer to execute.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset (in bytes) to the first batch in the <em>batchBuffer</em> .</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#af5ce6b5c1b92773ad7ff3eeacf0382bd" title="Draws a number of vertices from the currently bound vertex buffer.">draw</a></dd></dl>

</div>
</div>
<a id="a657800c43445c3ac118037d478a0d9d3" name="a657800c43445c3ac118037d478a0d9d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a657800c43445c3ac118037d478a0d9d3">&#9670;&#160;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void LiteFX::Rendering::ICommandBuffer::end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ends recording commands on the command buffer. </p>
<p>It is valid to call this method multiple times. If a command buffer is already closed, nothing will happen. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ad08533dccdc780f870b9a5895aa3633b" title="Sets the command buffer into recording state, so that it can receive command that should be submitted...">begin</a></dd></dl>

<p>Implemented in <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_direct_x12_command_buffer.html#a862deed4385cf89496cc8e9c2ddde70f">LiteFX::Rendering::Backends::DirectX12CommandBuffer</a>, and <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_vulkan_command_buffer.html#a2db74c40d8532bdf9eeec8debe134d3a">LiteFX::Rendering::Backends::VulkanCommandBuffer</a>.</p>

</div>
</div>
<a id="a5c33e0960019a09d715c462006b2e01b" name="a5c33e0960019a09d715c462006b2e01b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c33e0960019a09d715c462006b2e01b">&#9670;&#160;</a></span>execute() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LiteFX::Rendering::ICommandBuffer::execute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_lite_f_x.html#a58ddcdf7464eb219bb14d225153daa7f">SharedPtr</a>&lt; const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_buffer.html">ICommandBuffer</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>commandBuffer</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes a secondary command buffer/bundle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commandBuffer</td><td>The secondary command buffer/bundle to execute.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a80c63a811f06993da32c5cb5688ced84" name="a80c63a811f06993da32c5cb5688ced84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80c63a811f06993da32c5cb5688ced84">&#9670;&#160;</a></span>execute() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LiteFX::Rendering::ICommandBuffer::execute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_lite_f_x_1_1_enumerable.html">Enumerable</a>&lt; <a class="el" href="namespace_lite_f_x.html#a58ddcdf7464eb219bb14d225153daa7f">SharedPtr</a>&lt; const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_buffer.html">ICommandBuffer</a> &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>commandBuffers</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes a series of secondary command buffers/bundles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commandBuffers</td><td>The command buffers to execute.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5184ae021db9aa5324b0ca508164e717" name="a5184ae021db9aa5324b0ca508164e717"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5184ae021db9aa5324b0ca508164e717">&#9670;&#160;</a></span>isSecondary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool LiteFX::Rendering::ICommandBuffer::isSecondary </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code>, if the command buffer is a secondary command buffer, or <code>false</code> otherwise. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code>, if the command buffer is a secondary command buffer, or <code>false</code> otherwise.</dd></dl>

<p>Implemented in <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_direct_x12_command_buffer.html#ad82d529dd56df66ef9394e574230fc2d">LiteFX::Rendering::Backends::DirectX12CommandBuffer</a>, and <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_vulkan_command_buffer.html#ad6038cc71c956cad1f07ccb67b0a37ab">LiteFX::Rendering::Backends::VulkanCommandBuffer</a>.</p>

</div>
</div>
<a id="acdc19aa9dc8455bcbcb42c8f28644bce" name="acdc19aa9dc8455bcbcb42c8f28644bce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdc19aa9dc8455bcbcb42c8f28644bce">&#9670;&#160;</a></span>makeBarrier()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_lite_f_x.html#a6daa7ddc3f560528522ba2849e09e3d3">UniquePtr</a>&lt; <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_barrier.html">IBarrier</a> &gt; LiteFX::Rendering::ICommandBuffer::makeBarrier </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_rendering.html#ad0c4e431db149130a77cfbbbe1aa8235">PipelineStage</a></td>          <td class="paramname"><span class="paramname"><em>syncBefore</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_rendering.html#ad0c4e431db149130a77cfbbbe1aa8235">PipelineStage</a></td>          <td class="paramname"><span class="paramname"><em>syncAfter</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new barrier instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">syncBefore</td><td>The pipeline stage(s) all previous commands have to finish before the barrier is executed.</td></tr>
    <tr><td class="paramname">syncAfter</td><td>The pipeline stage(s) all subsequent commands are blocked at until the barrier is executed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The instance of the barrier.</dd></dl>

</div>
</div>
<a id="aa985c87b29268d58c4287e71aa6c2fcf" name="aa985c87b29268d58c4287e71aa6c2fcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa985c87b29268d58c4287e71aa6c2fcf">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_buffer.html">ICommandBuffer</a> &amp; LiteFX::Rendering::ICommandBuffer::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_buffer.html">ICommandBuffer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aaac74bb678cf59017823028ca7ecfb62" name="aaac74bb678cf59017823028ca7ecfb62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaac74bb678cf59017823028ca7ecfb62">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_buffer.html">ICommandBuffer</a> &amp; LiteFX::Rendering::ICommandBuffer::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_buffer.html">ICommandBuffer</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2cd9ebc23af8403b28676f460568b520" name="a2cd9ebc23af8403b28676f460568b520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cd9ebc23af8403b28676f460568b520">&#9670;&#160;</a></span>pushConstants()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LiteFX::Rendering::ICommandBuffer::pushConstants </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_push_constants_layout.html">IPushConstantsLayout</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>layout</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *const</td>          <td class="paramname"><span class="paramname"><em>memory</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pushes a block of memory into the push constants backing memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layout</td><td>The layout of the push constants to update.</td></tr>
    <tr><td class="paramname">memory</td><td>A pointer to the source memory.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a866d6746ae7d5384a099852b5bafa527" name="a866d6746ae7d5384a099852b5bafa527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a866d6746ae7d5384a099852b5bafa527">&#9670;&#160;</a></span>queue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_lite_f_x.html#a58ddcdf7464eb219bb14d225153daa7f">SharedPtr</a>&lt; const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_queue.html">ICommandQueue</a> &gt; LiteFX::Rendering::ICommandBuffer::queue </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a pointer to the command queue that this command buffer was allocated from or <code>nullptr</code>, if the queue has already been released. </p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the command queue that this command buffer was allocated from.</dd></dl>

</div>
</div>
<a id="a684b278b20a31c08cff01fbbb56a3a7a" name="a684b278b20a31c08cff01fbbb56a3a7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a684b278b20a31c08cff01fbbb56a3a7a">&#9670;&#160;</a></span>releaseSharedState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void LiteFX::Rendering::ICommandBuffer::releaseSharedState </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called by the parent command queue to signal that the command buffer should release it's shared state. </p>

</div>
</div>
<a id="a15977513058f559f7fb09c7abbd4df17" name="a15977513058f559f7fb09c7abbd4df17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15977513058f559f7fb09c7abbd4df17">&#9670;&#160;</a></span>setBlendFactors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void LiteFX::Rendering::ICommandBuffer::setBlendFactors </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_math_1_1_vector4f.html">Vector4f</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>blendFactors</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the blend factors for the subsequent draw calls. </p>
<p>Blend factors are set for all render targets that use the blend modes <code><a class="el" href="namespace_lite_f_x_1_1_rendering.html#a1be466b85553d7077fd3607e3dae3626aeb8eb99f8eea9079c0e76d5ce7301dd3">BlendFactor::ConstantColor</a></code>, <code><a class="el" href="namespace_lite_f_x_1_1_rendering.html#a1be466b85553d7077fd3607e3dae3626a13ab8deb1c606ab17745354b4e92f43a">BlendFactor::OneMinusConstantColor</a></code>, <code><a class="el" href="namespace_lite_f_x_1_1_rendering.html#a1be466b85553d7077fd3607e3dae3626a6f0229db491c3b01860363456dc57288">BlendFactor::ConstantAlpha</a></code> or <code><a class="el" href="namespace_lite_f_x_1_1_rendering.html#a1be466b85553d7077fd3607e3dae3626a9a1874144125c69e93ec99f17e985e41">BlendFactor::OneMinusConstantAlpha</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blendFactors</td><td>The blend factors for the subsequent draw calls.</td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_direct_x12_command_buffer.html#a9e3af7ec2463626088ec9724f36ecc4a">LiteFX::Rendering::Backends::DirectX12CommandBuffer</a>, and <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_vulkan_command_buffer.html#a97ea84f9d5d5de234b875832029d6c77">LiteFX::Rendering::Backends::VulkanCommandBuffer</a>.</p>

</div>
</div>
<a id="a687637f8cc8cf2353c6e8bfdc79b7d3c" name="a687637f8cc8cf2353c6e8bfdc79b7d3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a687637f8cc8cf2353c6e8bfdc79b7d3c">&#9670;&#160;</a></span>setScissors() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void LiteFX::Rendering::ICommandBuffer::setScissors </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_scissor.html">IScissor</a> *</td>          <td class="paramname"><span class="paramname"><em>scissor</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the scissor rectangle used for the subsequent draw calls. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scissors</td><td>The scissor rectangle used for the subsequent draw calls.</td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_direct_x12_command_buffer.html#a55f4d0d70a61d442f16d743473b0e216">LiteFX::Rendering::Backends::DirectX12CommandBuffer</a>, and <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_vulkan_command_buffer.html#a3df7f3c43e431fdcc523df70e49e65e7">LiteFX::Rendering::Backends::VulkanCommandBuffer</a>.</p>

</div>
</div>
<a id="aa216756129ae08431eeb61ee1f8bbebd" name="aa216756129ae08431eeb61ee1f8bbebd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa216756129ae08431eeb61ee1f8bbebd">&#9670;&#160;</a></span>setScissors() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void LiteFX::Rendering::ICommandBuffer::setScissors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x.html#aacf6de04faf43ec99887d011dd065ef4">Span</a>&lt; const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_scissor.html">IScissor</a> * &gt;</td>          <td class="paramname"><span class="paramname"><em>scissors</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the scissor rectangles used for the subsequent draw calls. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scissors</td><td>The scissor rectangles used for the subsequent draw calls.</td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_direct_x12_command_buffer.html#a8807c89edc647a367db2af2eb620ed0b">LiteFX::Rendering::Backends::DirectX12CommandBuffer</a>, and <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_vulkan_command_buffer.html#aff7d891ac6a0a184e59a0f0c65e8e561">LiteFX::Rendering::Backends::VulkanCommandBuffer</a>.</p>

</div>
</div>
<a id="ae15e58df15cdb65c53b1305a6a202b47" name="ae15e58df15cdb65c53b1305a6a202b47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae15e58df15cdb65c53b1305a6a202b47">&#9670;&#160;</a></span>setStencilRef()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void LiteFX::Rendering::ICommandBuffer::setStencilRef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a></td>          <td class="paramname"><span class="paramname"><em>stencilRef</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the stencil reference for the subsequent draw calls. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stencilRef</td><td>The stencil reference for the subsequent draw calls.</td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_direct_x12_command_buffer.html#a8e76d09ce2815a6784b746edc63c0e1d">LiteFX::Rendering::Backends::DirectX12CommandBuffer</a>, and <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_vulkan_command_buffer.html#a8df73c01b1e401d99855d83202ab5ea9">LiteFX::Rendering::Backends::VulkanCommandBuffer</a>.</p>

</div>
</div>
<a id="a219e95355a72a766857ff844065d04a4" name="a219e95355a72a766857ff844065d04a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a219e95355a72a766857ff844065d04a4">&#9670;&#160;</a></span>setViewports() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void LiteFX::Rendering::ICommandBuffer::setViewports </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_viewport.html">IViewport</a> *</td>          <td class="paramname"><span class="paramname"><em>viewport</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the viewport used for the subsequent draw calls. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">viewport</td><td>The viewport used for the subsequent draw calls.</td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_direct_x12_command_buffer.html#a3886e33f5b8e61a33e6586f78a3f84b1">LiteFX::Rendering::Backends::DirectX12CommandBuffer</a>, and <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_vulkan_command_buffer.html#addf1df1d98ff9aa6947d7f6012280fd8">LiteFX::Rendering::Backends::VulkanCommandBuffer</a>.</p>

</div>
</div>
<a id="aad05010ea75366d7c5d81945967ec9c9" name="aad05010ea75366d7c5d81945967ec9c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad05010ea75366d7c5d81945967ec9c9">&#9670;&#160;</a></span>setViewports() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void LiteFX::Rendering::ICommandBuffer::setViewports </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x.html#aacf6de04faf43ec99887d011dd065ef4">Span</a>&lt; const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_viewport.html">IViewport</a> * &gt;</td>          <td class="paramname"><span class="paramname"><em>viewports</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the viewports used for the subsequent draw calls. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">viewports</td><td>The viewports used for the subsequent draw calls.</td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_direct_x12_command_buffer.html#af7781d111616bc4be0bffdf269153faf">LiteFX::Rendering::Backends::DirectX12CommandBuffer</a>, and <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_vulkan_command_buffer.html#a722b2be8f1777103d23e859fbb94bcb0">LiteFX::Rendering::Backends::VulkanCommandBuffer</a>.</p>

</div>
</div>
<a id="a03a13eb3eefcdb8be47986354e3d69ac" name="a03a13eb3eefcdb8be47986354e3d69ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03a13eb3eefcdb8be47986354e3d69ac">&#9670;&#160;</a></span>submit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespace_lite_f_x_1_1_math.html#a42c7bab2ce6b3575c6e1316cd87de457">UInt64</a> LiteFX::Rendering::ICommandBuffer::submit </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Submits the command buffer to parent command. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_lite_f_x_1_1_runtime_exception.html" title="An exception that is thrown, if a requested operation could not be executed.">RuntimeException</a></td><td>Thrown, if the command buffer is a secondary command buffer.</td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_direct_x12_command_buffer.html#ab1ed70526e30e1bfc209faea04673a00">LiteFX::Rendering::Backends::DirectX12CommandBuffer</a>, and <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_vulkan_command_buffer.html#ad2e9b17e3484eec0a16bc2f869611cc7">LiteFX::Rendering::Backends::VulkanCommandBuffer</a>.</p>

</div>
</div>
<a id="aac0a545048689fe53304953614511425" name="aac0a545048689fe53304953614511425"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac0a545048689fe53304953614511425">&#9670;&#160;</a></span>traceRays() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LiteFX::Rendering::ICommandBuffer::traceRays </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_math_1_1_vector3u.html">Vector3u</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>dimensions</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_lite_f_x_1_1_rendering_1_1_shader_binding_table_offsets.html">ShaderBindingTableOffsets</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>offsets</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rayGenerationShaderBindingTable</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> *</td>          <td class="paramname"><span class="paramname"><em>missShaderBindingTable</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> *</td>          <td class="paramname"><span class="paramname"><em>hitShaderBindingTable</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> *</td>          <td class="paramname"><span class="paramname"><em>callableShaderBindingTable</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes a query on a ray-tracing pipeline. </p>
<p>This method is only supported if the GraphicsDeviceFeature::RayTracing feature is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dimensions</td><td>The dimensions of the ray-tracing query.</td></tr>
    <tr><td class="paramname">offsets</td><td>The offsets, sizes and strides for each shader binding table.</td></tr>
    <tr><td class="paramname">rayGenerationShaderBindingTable</td><td>The shader binding table that contains the ray generation shader.</td></tr>
    <tr><td class="paramname">missShaderBindingTable</td><td>The shader binding table that contains the miss shaders.</td></tr>
    <tr><td class="paramname">hitShaderBindingTable</td><td>The shader binding table that contains the hit shaders.</td></tr>
    <tr><td class="paramname">callableShaderBindingTable</td><td>The shader binding table that contains the callable shaders.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0d7e616cfa56a42ceb086246d32c2511" name="a0d7e616cfa56a42ceb086246d32c2511"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d7e616cfa56a42ceb086246d32c2511">&#9670;&#160;</a></span>traceRays() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LiteFX::Rendering::ICommandBuffer::traceRays </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a></td>          <td class="paramname"><span class="paramname"><em>width</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a></td>          <td class="paramname"><span class="paramname"><em>height</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a></td>          <td class="paramname"><span class="paramname"><em>depth</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_lite_f_x_1_1_rendering_1_1_shader_binding_table_offsets.html">ShaderBindingTableOffsets</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>offsets</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rayGenerationShaderBindingTable</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> *</td>          <td class="paramname"><span class="paramname"><em>missShaderBindingTable</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> *</td>          <td class="paramname"><span class="paramname"><em>hitShaderBindingTable</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> *</td>          <td class="paramname"><span class="paramname"><em>callableShaderBindingTable</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes a query on a ray-tracing pipeline. </p>
<p>This method is only supported if the GraphicsDeviceFeature::RayTracing feature is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>The width of the ray-tracing query.</td></tr>
    <tr><td class="paramname">height</td><td>The height of the ray-tracing query.</td></tr>
    <tr><td class="paramname">depth</td><td>The depth of the ray-tracing query.</td></tr>
    <tr><td class="paramname">offsets</td><td>The offsets, sizes and strides for each shader binding table.</td></tr>
    <tr><td class="paramname">rayGenerationShaderBindingTable</td><td>The shader binding table that contains the ray generation shader.</td></tr>
    <tr><td class="paramname">missShaderBindingTable</td><td>The shader binding table that contains the miss shaders.</td></tr>
    <tr><td class="paramname">hitShaderBindingTable</td><td>The shader binding table that contains the hit shaders.</td></tr>
    <tr><td class="paramname">callableShaderBindingTable</td><td>The shader binding table that contains the callable shaders.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a19a0010af97379721ddf59242481c15d" name="a19a0010af97379721ddf59242481c15d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19a0010af97379721ddf59242481c15d">&#9670;&#160;</a></span>track() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void LiteFX::Rendering::ICommandBuffer::track </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x.html#a58ddcdf7464eb219bb14d225153daa7f">SharedPtr</a>&lt; const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets up tracking for a buffer, so that it will not be destroyed until the command buffer has been executed. </p>
<p>When working with resources, often times you only need them for a single execution cycle of a command buffer. Having to manually check if the command buffer has been executed (by waiting for it's submission fence on the target queue) and releasing the resource afterwards can be difficult and intricate. <a class="el" href="class_lite_f_x_1_1_resource.html" title="Implements the IResource interface.">Resource</a> tracking allows the command buffer to store a reference of a resource and releasing it at some point after the command buffer has been executed automatically. Note that this does not automatically destroy the resource, which only happens if all references to it are released. However, if the only reference left is the one that is tracked by the command buffer, this process also destroys the resource.</p>
<p>Resources can only be tracked, if the command buffer is currently recording. The command buffer will not track uninitialized resources, i.e., a submitted <code>nullptr</code> will be discarded. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer to track.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_lite_f_x_1_1_runtime_exception.html" title="An exception that is thrown, if a requested operation could not be executed.">RuntimeException</a></td><td>Thrown, if the command buffer is not currently recording.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>track(SharedPtr&amp;le;const IImage&amp;ge;), track(SharedPtr&amp;le;const ISampler&amp;ge;)</dd></dl>

<p>Implemented in <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_direct_x12_command_buffer.html#a5466a34a4a198c077cb6a89674a7a3a6">LiteFX::Rendering::Backends::DirectX12CommandBuffer</a>, and <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_vulkan_command_buffer.html#a6ff2374d302458fa3a63c203ec5d132d">LiteFX::Rendering::Backends::VulkanCommandBuffer</a>.</p>

</div>
</div>
<a id="afa3cd495aff810b4b27e36e1798e0de3" name="afa3cd495aff810b4b27e36e1798e0de3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa3cd495aff810b4b27e36e1798e0de3">&#9670;&#160;</a></span>track() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void LiteFX::Rendering::ICommandBuffer::track </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x.html#a58ddcdf7464eb219bb14d225153daa7f">SharedPtr</a>&lt; const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_image.html">IImage</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>image</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets up tracking for an image, so that it will not be destroyed until the command buffer has been executed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>The image to track.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_lite_f_x_1_1_runtime_exception.html" title="An exception that is thrown, if a requested operation could not be executed.">RuntimeException</a></td><td>Thrown, if the command buffer is not currently recording.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>track(SharedPtr&amp;le;const IBuffer&amp;ge;)</dd></dl>

<p>Implemented in <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_direct_x12_command_buffer.html#a675c6022a31bb0efe69525f53e59e69c">LiteFX::Rendering::Backends::DirectX12CommandBuffer</a>, and <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_vulkan_command_buffer.html#a7255c39b184211543aad98e59e2fbbfa">LiteFX::Rendering::Backends::VulkanCommandBuffer</a>.</p>

</div>
</div>
<a id="aee6a49d3411bdd8767ab6a59828cb0f1" name="aee6a49d3411bdd8767ab6a59828cb0f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee6a49d3411bdd8767ab6a59828cb0f1">&#9670;&#160;</a></span>track() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void LiteFX::Rendering::ICommandBuffer::track </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x.html#a58ddcdf7464eb219bb14d225153daa7f">SharedPtr</a>&lt; const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_sampler.html">ISampler</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>sampler</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets up tracking for a sampler state, so that it will not be destroyed until the command buffer has been executed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sampler</td><td>The sampler to track.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_lite_f_x_1_1_runtime_exception.html" title="An exception that is thrown, if a requested operation could not be executed.">RuntimeException</a></td><td>Thrown, if the command buffer is not currently recording.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>track(SharedPtr&amp;le;const IBuffer&amp;ge;)</dd></dl>

<p>Implemented in <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_direct_x12_command_buffer.html#aa31a2831a18cfdc6d098127dd8ebe91d">LiteFX::Rendering::Backends::DirectX12CommandBuffer</a>, and <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_vulkan_command_buffer.html#a45cce0a80d6facfb32f5bc29a8036b9a">LiteFX::Rendering::Backends::VulkanCommandBuffer</a>.</p>

</div>
</div>
<a id="a3de8a81a5b0014f6ac40b3f05bdb673c" name="a3de8a81a5b0014f6ac40b3f05bdb673c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3de8a81a5b0014f6ac40b3f05bdb673c">&#9670;&#160;</a></span>transfer() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LiteFX::Rendering::ICommandBuffer::transfer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a></td>          <td class="paramname"><span class="paramname"><em>sourceElement</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a></td>          <td class="paramname"><span class="paramname"><em>targetElement</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a></td>          <td class="paramname"><span class="paramname"><em>elements</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a buffer-to-buffer transfer from <em>source</em>  to <em>target</em> . </p>
<p>Note that you have to manually ensure that <em>source</em>  and <em>target</em>  are in the proper state for transfer operations. You might have to use a <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_barrier.html" title="The interface for a barrier.">IBarrier</a> before starting the transfer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source buffer to transfer data from.</td></tr>
    <tr><td class="paramname">target</td><td>The target buffer to transfer data to.</td></tr>
    <tr><td class="paramname">sourceElement</td><td>The index of the first element in the source buffer to copy.</td></tr>
    <tr><td class="paramname">targetElement</td><td>The index of the first element in the target buffer to copy to.</td></tr>
    <tr><td class="paramname">elements</td><td>The number of elements to copy from the source buffer into the target buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_lite_f_x_1_1_argument_out_of_range_exception.html" title="An exception that is thrown, if a provided argument is not within the expected range.">ArgumentOutOfRangeException</a></td><td>Thrown, if the number of either the source buffer or the target buffer has not enough elements for the specified <em>elements</em>  parameter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_barrier.html" title="The interface for a barrier.">IBarrier</a></dd></dl>

</div>
</div>
<a id="a7e46c51a81afdaf31dbaf367c6629c39" name="a7e46c51a81afdaf31dbaf367c6629c39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e46c51a81afdaf31dbaf367c6629c39">&#9670;&#160;</a></span>transfer() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LiteFX::Rendering::ICommandBuffer::transfer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_image.html">IImage</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a></td>          <td class="paramname"><span class="paramname"><em>sourceElement</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a></td>          <td class="paramname"><span class="paramname"><em>firstSubresource</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a></td>          <td class="paramname"><span class="paramname"><em>elements</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a buffer-to-image transfer from <em>source</em>  to <em>target</em> . </p>
<p>The <em>subresource</em>  parameter describes the index of the first sub-resource to copy. Each element gets copied into the subsequent sub-resource, where resources are counted in the following order:</p>
<ul>
<li>
Level Contains the mip-map levels.  </li>
<li>
Layer Contains the array slices.  </li>
<li>
Plane Contains planes for multi-planar formats.  </li>
</ul>
<p>E.g., if 6 elements should be copied to an image with 3 mip-map levels and 3 layers, the elements 0-2 contain the mip-map levels of the first layer, while elements 3-5 contain the three mip-map levels of the second layer. The third layer would not receive any data in this example. If the image format has multiple planes, this procedure would be repeated for each plane, however one buffer element only maps to one sub-resource.</p>
<p>Note that you have to manually ensure that <em>source</em>  and <em>target</em>  are in the proper state for transfer operations. You might have to use a <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_barrier.html" title="The interface for a barrier.">IBarrier</a> before starting the transfer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source buffer to transfer data from.</td></tr>
    <tr><td class="paramname">target</td><td>The target image to transfer data to.</td></tr>
    <tr><td class="paramname">sourceElement</td><td>The index of the first element in the source buffer to copy.</td></tr>
    <tr><td class="paramname">firstSubresource</td><td>The index of the first sub-resource of the target image to receive data.</td></tr>
    <tr><td class="paramname">elements</td><td>The number of elements to copy from the source buffer into the target image sub-resources.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_lite_f_x_1_1_argument_out_of_range_exception.html" title="An exception that is thrown, if a provided argument is not within the expected range.">ArgumentOutOfRangeException</a></td><td>Thrown, if the number of either the source buffer or the target buffer has not enough elements for the specified <em>elements</em>  parameter.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aef34cddd04b35ce8ef644b56a1885b3b" name="aef34cddd04b35ce8ef644b56a1885b3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef34cddd04b35ce8ef644b56a1885b3b">&#9670;&#160;</a></span>transfer() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LiteFX::Rendering::ICommandBuffer::transfer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_image.html">IImage</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a></td>          <td class="paramname"><span class="paramname"><em>firstSubresource</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a></td>          <td class="paramname"><span class="paramname"><em>targetElement</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a></td>          <td class="paramname"><span class="paramname"><em>subresources</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs an image-to-buffer transfer from <em>source</em>  to <em>target</em> . </p>
<p>The <em>firstSubresource</em>  parameter describes the index of the first sub-resource to copy. Each element gets copied into the subsequent sub-resource, where resources are counted in the following order:</p>
<ul>
<li>
Level Contains the mip-map levels.  </li>
<li>
Layer Contains the array slices.  </li>
<li>
Plane Contains planes for multi-planar formats.  </li>
</ul>
<p>E.g., if 6 elements should be copied to an image with 3 mip-map levels and 3 layers, the elements 0-2 contain the mip-map levels of the first layer, while elements 3-5 contain the three mip-map levels of the second layer. The third layer would not receive any data in this example. If the image format has multiple planes, this procedure would be repeated for each plane, however one buffer element only maps to one sub-resource.</p>
<p>Note that you have to manually ensure that <em>source</em>  and <em>target</em>  are in the proper state for transfer operations. You might have to use a <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_barrier.html" title="The interface for a barrier.">IBarrier</a> before starting the transfer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source image to transfer data from.</td></tr>
    <tr><td class="paramname">target</td><td>The target buffer to transfer data to.</td></tr>
    <tr><td class="paramname">firstSubresource</td><td>The index of the first sub-resource to copy from the source image.</td></tr>
    <tr><td class="paramname">targetElement</td><td>The index of the first target element to receive data.</td></tr>
    <tr><td class="paramname">subresources</td><td>The number of sub-resources to copy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_lite_f_x_1_1_argument_out_of_range_exception.html" title="An exception that is thrown, if a provided argument is not within the expected range.">ArgumentOutOfRangeException</a></td><td>Thrown, if the number of either the source buffer or the target buffer has not enough elements for the specified <em>elements</em>  parameter.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6bfa216edf4732078742bd9db5536798" name="a6bfa216edf4732078742bd9db5536798"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bfa216edf4732078742bd9db5536798">&#9670;&#160;</a></span>transfer() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LiteFX::Rendering::ICommandBuffer::transfer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_image.html">IImage</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_image.html">IImage</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a></td>          <td class="paramname"><span class="paramname"><em>sourceSubresource</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a></td>          <td class="paramname"><span class="paramname"><em>targetSubresource</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a></td>          <td class="paramname"><span class="paramname"><em>subresources</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs an image-to-image transfer from <em>source</em>  to <em>target</em> . </p>
<p>Note that you have to manually ensure that <em>source</em>  and <em>target</em>  are in the proper state for transfer operations. You might have to use a <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_barrier.html" title="The interface for a barrier.">IBarrier</a> before starting the transfer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source image to transfer data from.</td></tr>
    <tr><td class="paramname">target</td><td>The target image to transfer data to.</td></tr>
    <tr><td class="paramname">sourceSubresource</td><td>The index of the first sub-resource to copy from the source image.</td></tr>
    <tr><td class="paramname">targetSubresource</td><td>The image of the first sub-resource in the target image to receive data.</td></tr>
    <tr><td class="paramname">subresources</td><td>The number of sub-resources to copy between the images.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_lite_f_x_1_1_argument_out_of_range_exception.html" title="An exception that is thrown, if a provided argument is not within the expected range.">ArgumentOutOfRangeException</a></td><td>Thrown, if the number of either the source buffer or the target buffer has not enough elements for the specified <em>elements</em>  parameter.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8db0ed5d6cd741ad669fafc05a0e2037" name="a8db0ed5d6cd741ad669fafc05a0e2037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8db0ed5d6cd741ad669fafc05a0e2037">&#9670;&#160;</a></span>transfer() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LiteFX::Rendering::ICommandBuffer::transfer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_lite_f_x.html#a58ddcdf7464eb219bb14d225153daa7f">SharedPtr</a>&lt; const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a></td>          <td class="paramname"><span class="paramname"><em>sourceElement</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a></td>          <td class="paramname"><span class="paramname"><em>targetElement</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a></td>          <td class="paramname"><span class="paramname"><em>elements</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a buffer-to-buffer transfer from <em>source</em>  to <em>target</em> . </p>
<p>This method takes shared ownership over <em>source</em> , which means that a reference is hold until the parent command queue finished using the command buffer. At this point, the command queue calls <a class="el" href="#a684b278b20a31c08cff01fbbb56a3a7a" title="Called by the parent command queue to signal that the command buffer should release it&#39;s shared state...">releaseSharedState</a> to release all shared references. Note that this is a relaxed constraint. It is only guaranteed, that the queue calls this method at some point after the command buffer has been executed.</p>
<p>Sharing ownership is helpful in situations where you only have a temporary buffer that you do not want to manually keep track of. For example, it makes sense to create a temporary staging buffer and delete it, if the remote resource has been initialized. In such a case, the command buffer can take ownership over the resource to release it after it has been executed.</p>
<p>Note that you have to manually ensure that <em>source</em>  and <em>target</em>  are in the proper state for transfer operations. You might have to use a <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_barrier.html" title="The interface for a barrier.">IBarrier</a> before starting the transfer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source buffer to transfer data from.</td></tr>
    <tr><td class="paramname">target</td><td>The target buffer to transfer data to.</td></tr>
    <tr><td class="paramname">sourceElement</td><td>The index of the first element in the source buffer to copy.</td></tr>
    <tr><td class="paramname">targetElement</td><td>The index of the first element in the target buffer to copy to.</td></tr>
    <tr><td class="paramname">elements</td><td>The number of elements to copy from the source buffer into the target buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_lite_f_x_1_1_argument_out_of_range_exception.html" title="An exception that is thrown, if a provided argument is not within the expected range.">ArgumentOutOfRangeException</a></td><td>Thrown, if the number of either the source buffer or the target buffer has not enough elements for the specified <em>elements</em>  parameter.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9f7a480a90943026e7b9cf854489391f" name="a9f7a480a90943026e7b9cf854489391f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f7a480a90943026e7b9cf854489391f">&#9670;&#160;</a></span>transfer() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LiteFX::Rendering::ICommandBuffer::transfer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_lite_f_x.html#a58ddcdf7464eb219bb14d225153daa7f">SharedPtr</a>&lt; const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_image.html">IImage</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a></td>          <td class="paramname"><span class="paramname"><em>sourceElement</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a></td>          <td class="paramname"><span class="paramname"><em>firstSubresource</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a></td>          <td class="paramname"><span class="paramname"><em>elements</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a buffer-to-image transfer from <em>source</em>  to <em>target</em> . </p>
<p>The <em>subresource</em>  parameter describes the index of the first sub-resource to copy. Each element gets copied into the subsequent sub-resource, where resources are counted in the following order:</p>
<ul>
<li>
Level Contains the mip-map levels.  </li>
<li>
Layer Contains the array slices.  </li>
<li>
Plane Contains planes for multi-planar formats.  </li>
</ul>
<p>E.g., if 6 elements should be copied to an image with 3 mip-map levels and 3 layers, the elements 0-2 contain the mip-map levels of the first layer, while elements 3-5 contain the three mip-map levels of the second layer. The third layer would not receive any data in this example. If the image format has multiple planes, this procedure would be repeated for each plane, however one buffer element only maps to one sub-resource.</p>
<p>This method takes shared ownership over <em>source</em> , which means that a reference is hold until the parent command queue finished using the command buffer. At this point, the command queue calls <a class="el" href="#a684b278b20a31c08cff01fbbb56a3a7a" title="Called by the parent command queue to signal that the command buffer should release it&#39;s shared state...">releaseSharedState</a> to release all shared references. Note that this is a relaxed constraint. It is only guaranteed, that the queue calls this method at some point after the command buffer has been executed.</p>
<p>Sharing ownership is helpful in situations where you only have a temporary buffer that you do not want to manually keep track of. For example, it makes sense to create a temporary staging buffer and delete it, if the remote resource has been initialized. In such a case, the command buffer can take ownership over the resource to release it after it has been executed.</p>
<p>Note that you have to manually ensure that <em>source</em>  and <em>target</em>  are in the proper state for transfer operations. You might have to use a <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_barrier.html" title="The interface for a barrier.">IBarrier</a> before starting the transfer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source buffer to transfer data from.</td></tr>
    <tr><td class="paramname">target</td><td>The target image to transfer data to.</td></tr>
    <tr><td class="paramname">sourceElement</td><td>The index of the first element in the source buffer to copy.</td></tr>
    <tr><td class="paramname">firstSubresource</td><td>The index of the first sub-resource of the target image to receive data.</td></tr>
    <tr><td class="paramname">elements</td><td>The number of elements to copy from the source buffer into the target image sub-resources.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_lite_f_x_1_1_argument_out_of_range_exception.html" title="An exception that is thrown, if a provided argument is not within the expected range.">ArgumentOutOfRangeException</a></td><td>Thrown, if the number of either the source buffer or the target buffer has not enough elements for the specified <em>elements</em>  parameter.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6607074f4c6d56d2d3448ab48cd95522" name="a6607074f4c6d56d2d3448ab48cd95522"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6607074f4c6d56d2d3448ab48cd95522">&#9670;&#160;</a></span>transfer() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LiteFX::Rendering::ICommandBuffer::transfer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_lite_f_x.html#a58ddcdf7464eb219bb14d225153daa7f">SharedPtr</a>&lt; const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_image.html">IImage</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a></td>          <td class="paramname"><span class="paramname"><em>firstSubresource</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a></td>          <td class="paramname"><span class="paramname"><em>targetElement</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a></td>          <td class="paramname"><span class="paramname"><em>subresources</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs an image-to-buffer transfer from <em>source</em>  to <em>target</em> . </p>
<p>The <em>firstSubresource</em>  parameter describes the index of the first sub-resource to copy. Each element gets copied into the subsequent sub-resource, where resources are counted in the following order:</p>
<ul>
<li>
Level Contains the mip-map levels.  </li>
<li>
Layer Contains the array slices.  </li>
<li>
Plane Contains planes for multi-planar formats.  </li>
</ul>
<p>E.g., if 6 elements should be copied to an image with 3 mip-map levels and 3 layers, the elements 0-2 contain the mip-map levels of the first layer, while elements 3-5 contain the three mip-map levels of the second layer. The third layer would not receive any data in this example. If the image format has multiple planes, this procedure would be repeated for each plane, however one buffer element only maps to one sub-resource.</p>
<p>This method takes shared ownership over <em>source</em> , which means that a reference is hold until the parent command queue finished using the command buffer. At this point, the command queue calls <a class="el" href="#a684b278b20a31c08cff01fbbb56a3a7a" title="Called by the parent command queue to signal that the command buffer should release it&#39;s shared state...">releaseSharedState</a> to release all shared references. Note that this is a relaxed constraint. It is only guaranteed, that the queue calls this method at some point after the command buffer has been executed.</p>
<p>Sharing ownership is helpful in situations where you only have a temporary buffer that you do not want to manually keep track of. For example, it makes sense to create a temporary staging buffer and delete it, if the remote resource has been initialized. In such a case, the command buffer can take ownership over the resource to release it after it has been executed.</p>
<p>Note that you have to manually ensure that <em>source</em>  and <em>target</em>  are in the proper state for transfer operations. You might have to use a <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_barrier.html" title="The interface for a barrier.">IBarrier</a> before starting the transfer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source image to transfer data from.</td></tr>
    <tr><td class="paramname">target</td><td>The target buffer to transfer data to.</td></tr>
    <tr><td class="paramname">firstSubresource</td><td>The index of the first sub-resource to copy from the source image.</td></tr>
    <tr><td class="paramname">targetElement</td><td>The index of the first target element to receive data.</td></tr>
    <tr><td class="paramname">subresources</td><td>The number of sub-resources to copy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_lite_f_x_1_1_argument_out_of_range_exception.html" title="An exception that is thrown, if a provided argument is not within the expected range.">ArgumentOutOfRangeException</a></td><td>Thrown, if the number of either the source buffer or the target buffer has not enough elements for the specified <em>elements</em>  parameter.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a708d9cfe459ba1edc1eadd389d0ab75e" name="a708d9cfe459ba1edc1eadd389d0ab75e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a708d9cfe459ba1edc1eadd389d0ab75e">&#9670;&#160;</a></span>transfer() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LiteFX::Rendering::ICommandBuffer::transfer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_lite_f_x.html#a58ddcdf7464eb219bb14d225153daa7f">SharedPtr</a>&lt; const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_image.html">IImage</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_image.html">IImage</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a></td>          <td class="paramname"><span class="paramname"><em>sourceSubresource</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a></td>          <td class="paramname"><span class="paramname"><em>targetSubresource</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a></td>          <td class="paramname"><span class="paramname"><em>subresources</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs an image-to-image transfer from <em>source</em>  to <em>target</em> . </p>
<p>This method takes shared ownership over <em>source</em> , which means that a reference is hold until the parent command queue finished using the command buffer. At this point, the command queue calls <a class="el" href="#a684b278b20a31c08cff01fbbb56a3a7a" title="Called by the parent command queue to signal that the command buffer should release it&#39;s shared state...">releaseSharedState</a> to release all shared references. Note that this is a relaxed constraint. It is only guaranteed, that the queue calls this method at some point after the command buffer has been executed.</p>
<p>Sharing ownership is helpful in situations where you only have a temporary buffer that you do not want to manually keep track of. For example, it makes sense to create a temporary staging buffer and delete it, if the remote resource has been initialized. In such a case, the command buffer can take ownership over the resource to release it after it has been executed.</p>
<p>Note that you have to manually ensure that <em>source</em>  and <em>target</em>  are in the proper state for transfer operations. You might have to use a <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_barrier.html" title="The interface for a barrier.">IBarrier</a> before starting the transfer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source image to transfer data from.</td></tr>
    <tr><td class="paramname">target</td><td>The target image to transfer data to.</td></tr>
    <tr><td class="paramname">sourceSubresource</td><td>The index of the first sub-resource to copy from the source image.</td></tr>
    <tr><td class="paramname">targetSubresource</td><td>The image of the first sub-resource in the target image to receive data.</td></tr>
    <tr><td class="paramname">subresources</td><td>The number of sub-resources to copy between the images.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_lite_f_x_1_1_argument_out_of_range_exception.html" title="An exception that is thrown, if a provided argument is not within the expected range.">ArgumentOutOfRangeException</a></td><td>Thrown, if the number of either the source buffer or the target buffer has not enough elements for the specified <em>elements</em>  parameter.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9d710981d0e77b8331ab09c291c00c5d" name="a9d710981d0e77b8331ab09c291c00c5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d710981d0e77b8331ab09c291c00c5d">&#9670;&#160;</a></span>transfer() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LiteFX::Rendering::ICommandBuffer::transfer </td>
          <td>(</td>
          <td class="paramtype">const void *const</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a></td>          <td class="paramname"><span class="paramname"><em>targetElement</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a></td>          <td class="paramname"><span class="paramname"><em>elements</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a buffer-to-buffer transfer from a temporary buffer into <em>target</em> . </p>
<p>This method creates a temporary buffer and maps <em>data</em>  into it, before transferring it into <em>target</em> . A reference of the temporary buffer is stored until the parent command queue finished using the command buffer. At this point, the command queue calls <a class="el" href="#a684b278b20a31c08cff01fbbb56a3a7a" title="Called by the parent command queue to signal that the command buffer should release it&#39;s shared state...">releaseSharedState</a> to release all shared references. Note that this is a relaxed constraint. It is only guaranteed, that the queue calls this method at some point after the command buffer has been executed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The address that marks the beginning of the data to map.</td></tr>
    <tr><td class="paramname">size</td><td>The number of bytes to map.</td></tr>
    <tr><td class="paramname">target</td><td>The target buffer to transfer data to.</td></tr>
    <tr><td class="paramname">targetElement</td><td>The array element to map the data to.</td></tr>
    <tr><td class="paramname">elements</td><td>The number of elements to copy.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a37e992e52361628dfa46cc076892e9ad" name="a37e992e52361628dfa46cc076892e9ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37e992e52361628dfa46cc076892e9ad">&#9670;&#160;</a></span>transfer() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LiteFX::Rendering::ICommandBuffer::transfer </td>
          <td>(</td>
          <td class="paramtype">const void *const</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_image.html">IImage</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a></td>          <td class="paramname"><span class="paramname"><em>subresource</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a buffer-to-buffer transfer from a temporary buffer into <em>target</em> . </p>
<p>This method creates a temporary buffer and maps <em>data</em>  into it, before transferring it into <em>target</em> . A reference of the temporary buffer is stored until the parent command queue finished using the command buffer. At this point, the command queue calls <a class="el" href="#a684b278b20a31c08cff01fbbb56a3a7a" title="Called by the parent command queue to signal that the command buffer should release it&#39;s shared state...">releaseSharedState</a> to release all shared references. Note that this is a relaxed constraint. It is only guaranteed, that the queue calls this method at some point after the command buffer has been executed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The address that marks the beginning of the data to map.</td></tr>
    <tr><td class="paramname">size</td><td>The number of bytes to map.</td></tr>
    <tr><td class="paramname">target</td><td>The target buffer to transfer data to.</td></tr>
    <tr><td class="paramname">firstSubresource</td><td>The index of the first sub-resource of the target image to receive data.</td></tr>
    <tr><td class="paramname">elements</td><td>The number of elements to copy from the source buffer into the target image sub-resources.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abb4741378af8d3e9033ef0ee2fb0474b" name="abb4741378af8d3e9033ef0ee2fb0474b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb4741378af8d3e9033ef0ee2fb0474b">&#9670;&#160;</a></span>transfer() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LiteFX::Rendering::ICommandBuffer::transfer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x.html#aacf6de04faf43ec99887d011dd065ef4">Span</a>&lt; const void *const &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>elementSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a></td>          <td class="paramname"><span class="paramname"><em>targetElement</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a buffer-to-buffer transfer from a temporary buffer into <em>target</em> . </p>
<p>This method creates a temporary buffer and maps <em>data</em>  into it, before transferring it into <em>target</em> . A reference of the temporary buffer is stored until the parent command queue finished using the command buffer. At this point, the command queue calls <a class="el" href="#a684b278b20a31c08cff01fbbb56a3a7a" title="Called by the parent command queue to signal that the command buffer should release it&#39;s shared state...">releaseSharedState</a> to release all shared references. Note that this is a relaxed constraint. It is only guaranteed, that the queue calls this method at some point after the command buffer has been executed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The addresses that mark the beginning of the element data to map.</td></tr>
    <tr><td class="paramname">elementSize</td><td>The number of bytes to map for each element.</td></tr>
    <tr><td class="paramname">target</td><td>The target buffer to transfer data to.</td></tr>
    <tr><td class="paramname">targetElement</td><td>The first array element to transfer the data to.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a297fa30147364ad3e66e067b41d932cb" name="a297fa30147364ad3e66e067b41d932cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a297fa30147364ad3e66e067b41d932cb">&#9670;&#160;</a></span>transfer() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LiteFX::Rendering::ICommandBuffer::transfer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x.html#aacf6de04faf43ec99887d011dd065ef4">Span</a>&lt; const void *const &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>elementSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_image.html">IImage</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a></td>          <td class="paramname"><span class="paramname"><em>firstSubresource</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a></td>          <td class="paramname"><span class="paramname"><em>elements</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a buffer-to-buffer transfer from a temporary buffer into <em>target</em> . </p>
<p>This method creates a temporary buffer and maps <em>data</em>  into it, before transferring it into <em>target</em> . A reference of the temporary buffer is stored until the parent command queue finished using the command buffer. At this point, the command queue calls <a class="el" href="#a684b278b20a31c08cff01fbbb56a3a7a" title="Called by the parent command queue to signal that the command buffer should release it&#39;s shared state...">releaseSharedState</a> to release all shared references. Note that this is a relaxed constraint. It is only guaranteed, that the queue calls this method at some point after the command buffer has been executed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The addresses that mark the beginning of the element data to map.</td></tr>
    <tr><td class="paramname">elementSize</td><td>The number of bytes to map for each element.</td></tr>
    <tr><td class="paramname">target</td><td>The target buffer to transfer data to.</td></tr>
    <tr><td class="paramname">firstSubresource</td><td>The index of the first sub-resource of the target image to receive data.</td></tr>
    <tr><td class="paramname">elements</td><td>The number of elements to copy from the source buffer into the target image sub-resources.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5f97a142688028c51ae8f75536a6c454" name="a5f97a142688028c51ae8f75536a6c454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f97a142688028c51ae8f75536a6c454">&#9670;&#160;</a></span>updateAccelerationStructure() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LiteFX::Rendering::ICommandBuffer::updateAccelerationStructure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_bottom_level_acceleration_structure.html">IBottomLevelAccelerationStructure</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>blas</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_lite_f_x.html#a58ddcdf7464eb219bb14d225153daa7f">SharedPtr</a>&lt; const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>scratchBuffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#a42c7bab2ce6b3575c6e1316cd87de457">UInt64</a></td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates a bottom-level acceleration structure. </p>
<p>This method is only supported if the GraphicsDeviceFeature::RayTracing feature is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blas</td><td>The bottom-level acceleration structure to build.</td></tr>
    <tr><td class="paramname">scratchBuffer</td><td>The scratch buffer to use for building the acceleration structure.</td></tr>
    <tr><td class="paramname">buffer</td><td>The buffer that contains the acceleration structure after the build.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset into <em>buffer</em>  at which the acceleration structure gets stored after the build.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_lite_f_x_1_1_argument_not_initialized_exception.html" title="An exception that is thrown, if a provided non-optional argument was not initialized.">ArgumentNotInitializedException</a></td><td>Thrown, if the provided <em>scratchBuffer</em>  is not initialized.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_acceleration_structure.html#aa41a80d20632be5288d3a1d69f291562" title="Performs a complete build of the acceleration structure.">IAccelerationStructure::build</a></dd></dl>

</div>
</div>
<a id="a174384b2e6bbba8a7c094369d816eabe" name="a174384b2e6bbba8a7c094369d816eabe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a174384b2e6bbba8a7c094369d816eabe">&#9670;&#160;</a></span>updateAccelerationStructure() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LiteFX::Rendering::ICommandBuffer::updateAccelerationStructure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_top_level_acceleration_structure.html">ITopLevelAccelerationStructure</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>tlas</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_lite_f_x.html#a58ddcdf7464eb219bb14d225153daa7f">SharedPtr</a>&lt; const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>scratchBuffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">IBuffer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_lite_f_x_1_1_math.html#a42c7bab2ce6b3575c6e1316cd87de457">UInt64</a></td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates a top-level acceleration structure. </p>
<p>This method is only supported if the GraphicsDeviceFeature::RayTracing feature is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tlas</td><td>The top-level acceleration structure to build.</td></tr>
    <tr><td class="paramname">scratchBuffer</td><td>The scratch buffer to use for building the acceleration structure.</td></tr>
    <tr><td class="paramname">buffer</td><td>The buffer that contains the acceleration structure after the build.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset into <em>buffer</em>  at which the acceleration structure gets stored after the build.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_lite_f_x_1_1_argument_not_initialized_exception.html" title="An exception that is thrown, if a provided non-optional argument was not initialized.">ArgumentNotInitializedException</a></td><td>Thrown, if the provided <em>scratchBuffer</em>  is not initialized.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_acceleration_structure.html#aa41a80d20632be5288d3a1d69f291562" title="Performs a complete build of the acceleration structure.">IAccelerationStructure::build</a></dd></dl>

</div>
</div>
<a id="a81dad499f968cc318887b5de2c88e237" name="a81dad499f968cc318887b5de2c88e237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81dad499f968cc318887b5de2c88e237">&#9670;&#160;</a></span>use()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LiteFX::Rendering::ICommandBuffer::use </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_pipeline.html">IPipeline</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pipeline</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the active pipeline state. </p>

</div>
</div>
<a id="a53aeccd0d446ae06bc849b4dccee1c9c" name="a53aeccd0d446ae06bc849b4dccee1c9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53aeccd0d446ae06bc849b4dccee1c9c">&#9670;&#160;</a></span>writeTimingEvent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void LiteFX::Rendering::ICommandBuffer::writeTimingEvent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_lite_f_x.html#a58ddcdf7464eb219bb14d225153daa7f">SharedPtr</a>&lt; const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_timing_event.html">TimingEvent</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>timingEvent</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the current GPU time stamp value for the timing event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timingEvent</td><td>The timing event for which the time stamp is written.</td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_direct_x12_command_buffer.html#a90389c1c733d46822b42be47315bd836">LiteFX::Rendering::Backends::DirectX12CommandBuffer</a>, and <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_vulkan_command_buffer.html#a06b7f2fe8c2c16da180f554cfa452514">LiteFX::Rendering::Backends::VulkanCommandBuffer</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="a8e4925e00c4b5cfd5ef1730118c7cf7a" name="a8e4925e00c4b5cfd5ef1730118c7cf7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e4925e00c4b5cfd5ef1730118c7cf7a">&#9670;&#160;</a></span>ICommandQueue</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_queue.html">ICommandQueue</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_lite_f_x.html">LiteFX</a></li><li class="navelem"><a class="el" href="namespace_lite_f_x_1_1_rendering.html">Rendering</a></li><li class="navelem"><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_command_buffer.html">ICommandBuffer</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
