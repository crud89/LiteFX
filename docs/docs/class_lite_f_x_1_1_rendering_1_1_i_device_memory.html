<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LiteFX: LiteFX::Rendering::IDeviceMemory Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="theme.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">LiteFX<span id="projectnumber">&#160;0.5.1.2025</span>
   </div>
   <div id="projectbrief">Computer Graphics Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('class_lite_f_x_1_1_rendering_1_1_i_device_memory.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="class_lite_f_x_1_1_rendering_1_1_i_device_memory-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">LiteFX::Rendering::IDeviceMemory Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>Describes a chunk of device memory.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="rendering__api_8hpp_source.html">rendering_api.hpp</a>&gt;</code></p>

<p>Inherited by <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_buffer.html">LiteFX::Rendering::IBuffer</a><code> [virtual]</code>, and <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_image.html">LiteFX::Rendering::IImage</a><code> [virtual]</code>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_lite_f_x_1_1_rendering_1_1_i_device_memory_1_1_prepare_move_event_args.html">PrepareMoveEventArgs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a reference to a barrier that can be used to synchronize accesses to the resource with a move operation.  <a href="struct_lite_f_x_1_1_rendering_1_1_i_device_memory_1_1_prepare_move_event_args.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_lite_f_x_1_1_rendering_1_1_i_device_memory_1_1_resource_moving_event_args.html">ResourceMovingEventArgs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the fence and the command queue to wait on for the fence before a moved resource can be used.  <a href="struct_lite_f_x_1_1_rendering_1_1_i_device_memory_1_1_resource_moving_event_args.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1899194e7d61373406c922cc5b336007" id="r_a1899194e7d61373406c922cc5b336007"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1899194e7d61373406c922cc5b336007">~IDeviceMemory</a> () noexcept=default</td></tr>
<tr class="separator:a1899194e7d61373406c922cc5b336007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aa9ff724ffbd7864ac58e4edb414c46" id="r_a9aa9ff724ffbd7864ac58e4edb414c46"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9aa9ff724ffbd7864ac58e4edb414c46">elements</a> () const noexcept=0</td></tr>
<tr class="memdesc:a9aa9ff724ffbd7864ac58e4edb414c46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of sub-resources inside the memory chunk.  <br /></td></tr>
<tr class="separator:a9aa9ff724ffbd7864ac58e4edb414c46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66f85883ca87702a04035e1e51af0e53" id="r_a66f85883ca87702a04035e1e51af0e53"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a66f85883ca87702a04035e1e51af0e53">size</a> () const noexcept=0</td></tr>
<tr class="memdesc:a66f85883ca87702a04035e1e51af0e53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size (in bytes) of the aligned memory chunk.  <br /></td></tr>
<tr class="separator:a66f85883ca87702a04035e1e51af0e53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f5bc5ff213aca68d049a18c995d3ef5" id="r_a0f5bc5ff213aca68d049a18c995d3ef5"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f5bc5ff213aca68d049a18c995d3ef5">elementSize</a> () const noexcept=0</td></tr>
<tr class="memdesc:a0f5bc5ff213aca68d049a18c995d3ef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of a single element within the buffer. If there is only one element, this is equal to <a class="el" href="#a66f85883ca87702a04035e1e51af0e53" title="Gets the size (in bytes) of the aligned memory chunk.">size</a>.  <br /></td></tr>
<tr class="separator:a0f5bc5ff213aca68d049a18c995d3ef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a992a32832746ca4f328711e9c924a5bd" id="r_a992a32832746ca4f328711e9c924a5bd"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a992a32832746ca4f328711e9c924a5bd">elementAlignment</a> () const noexcept=0</td></tr>
<tr class="memdesc:a992a32832746ca4f328711e9c924a5bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the alignment of a single element.  <br /></td></tr>
<tr class="separator:a992a32832746ca4f328711e9c924a5bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a379a3fbcd746e43f6c34f26f97e01b7c" id="r_a379a3fbcd746e43f6c34f26f97e01b7c"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a379a3fbcd746e43f6c34f26f97e01b7c">alignedElementSize</a> () const noexcept=0</td></tr>
<tr class="memdesc:a379a3fbcd746e43f6c34f26f97e01b7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the actual size of the element in device memory.  <br /></td></tr>
<tr class="separator:a379a3fbcd746e43f6c34f26f97e01b7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f597c3eecfe5e4d6909bd67ad962e64" id="r_a0f597c3eecfe5e4d6909bd67ad962e64"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespace_lite_f_x_1_1_rendering.html#a85e85c2c13e89d1aaadc8dcfad380951">ResourceUsage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f597c3eecfe5e4d6909bd67ad962e64">usage</a> () const noexcept=0</td></tr>
<tr class="memdesc:a0f597c3eecfe5e4d6909bd67ad962e64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the usage flags for the resource.  <br /></td></tr>
<tr class="separator:a0f597c3eecfe5e4d6909bd67ad962e64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e19d686770eb7c6f847e8f2ce78c79b" id="r_a7e19d686770eb7c6f847e8f2ce78c79b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespace_lite_f_x_1_1_math.html#a42c7bab2ce6b3575c6e1316cd87de457">UInt64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e19d686770eb7c6f847e8f2ce78c79b">virtualAddress</a> () const noexcept=0</td></tr>
<tr class="memdesc:a7e19d686770eb7c6f847e8f2ce78c79b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the address of the resource in GPU memory.  <br /></td></tr>
<tr class="separator:a7e19d686770eb7c6f847e8f2ce78c79b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cec9d7f1ee29d0f088d16b31cd3bb3e" id="r_a8cec9d7f1ee29d0f088d16b31cd3bb3e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8cec9d7f1ee29d0f088d16b31cd3bb3e">writable</a> () const noexcept</td></tr>
<tr class="memdesc:a8cec9d7f1ee29d0f088d16b31cd3bb3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code>, if the resource can be bound to a read/write descriptor.  <br /></td></tr>
<tr class="separator:a8cec9d7f1ee29d0f088d16b31cd3bb3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91f22c38dfa49a8fa39a55ca0feb38cb" id="r_a91f22c38dfa49a8fa39a55ca0feb38cb"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a91f22c38dfa49a8fa39a55ca0feb38cb">volatileMove</a> () const noexcept</td></tr>
<tr class="memdesc:a91f22c38dfa49a8fa39a55ca0feb38cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code>, if the contents of the resource should not be copied during a move.  <br /></td></tr>
<tr class="separator:a91f22c38dfa49a8fa39a55ca0feb38cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a127e1e946d18d05dabb385d5df0aa29d" id="r_a127e1e946d18d05dabb385d5df0aa29d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_lite_f_x_1_1_event.html">Event</a>&lt; const <a class="el" href="struct_lite_f_x_1_1_rendering_1_1_i_device_memory_1_1_prepare_move_event_args.html">PrepareMoveEventArgs</a> &amp; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a127e1e946d18d05dabb385d5df0aa29d">prepareMove</a></td></tr>
<tr class="memdesc:a127e1e946d18d05dabb385d5df0aa29d"><td class="mdescLeft">&#160;</td><td class="mdescRight">An event that gets invoked to prepare a resource for a move operation.  <br /></td></tr>
<tr class="separator:a127e1e946d18d05dabb385d5df0aa29d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0e56fb490b2ff583d559e5099af5916" id="r_af0e56fb490b2ff583d559e5099af5916"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_lite_f_x_1_1_event.html">Event</a>&lt; <a class="el" href="struct_lite_f_x_1_1_rendering_1_1_i_device_memory_1_1_resource_moving_event_args.html">ResourceMovingEventArgs</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af0e56fb490b2ff583d559e5099af5916">moving</a></td></tr>
<tr class="memdesc:af0e56fb490b2ff583d559e5099af5916"><td class="mdescLeft">&#160;</td><td class="mdescRight">An event that gets invoked before a resource is copied during a move.  <br /></td></tr>
<tr class="separator:af0e56fb490b2ff583d559e5099af5916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae935df7a7d5ecaff70e7fbc7b974b477" id="r_ae935df7a7d5ecaff70e7fbc7b974b477"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_lite_f_x_1_1_event.html">Event</a>&lt; <a class="el" href="class_lite_f_x_1_1_event_args.html">EventArgs</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae935df7a7d5ecaff70e7fbc7b974b477">moved</a></td></tr>
<tr class="memdesc:ae935df7a7d5ecaff70e7fbc7b974b477"><td class="mdescLeft">&#160;</td><td class="mdescRight">An event that gets invoked, after the resource has been moved to a different location, but before the old resource gets destroyed.  <br /></td></tr>
<tr class="separator:ae935df7a7d5ecaff70e7fbc7b974b477"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:af33d0b51c3bfc50bfa82f5a8e509b918" id="r_af33d0b51c3bfc50bfa82f5a8e509b918"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af33d0b51c3bfc50bfa82f5a8e509b918">IDeviceMemory</a> () noexcept=default</td></tr>
<tr class="separator:af33d0b51c3bfc50bfa82f5a8e509b918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b28ad410caee3b9eb9572c089eac2ad" id="r_a7b28ad410caee3b9eb9572c089eac2ad"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b28ad410caee3b9eb9572c089eac2ad">IDeviceMemory</a> (<a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_device_memory.html">IDeviceMemory</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="separator:a7b28ad410caee3b9eb9572c089eac2ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7240fbd1a6fff2ce3d097a8c9e27c13" id="r_ae7240fbd1a6fff2ce3d097a8c9e27c13"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae7240fbd1a6fff2ce3d097a8c9e27c13">IDeviceMemory</a> (const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_device_memory.html">IDeviceMemory</a> &amp;)=default</td></tr>
<tr class="separator:ae7240fbd1a6fff2ce3d097a8c9e27c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49e7c333b36dda5742cef529abef1ef3" id="r_a49e7c333b36dda5742cef529abef1ef3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_device_memory.html">IDeviceMemory</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a49e7c333b36dda5742cef529abef1ef3">operator=</a> (<a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_device_memory.html">IDeviceMemory</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="separator:a49e7c333b36dda5742cef529abef1ef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a883e0fd5eb6bb4460649e0a7114ec0cc" id="r_a883e0fd5eb6bb4460649e0a7114ec0cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_device_memory.html">IDeviceMemory</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a883e0fd5eb6bb4460649e0a7114ec0cc">operator=</a> (const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_device_memory.html">IDeviceMemory</a> &amp;)=default</td></tr>
<tr class="separator:a883e0fd5eb6bb4460649e0a7114ec0cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Describes a chunk of device memory. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af33d0b51c3bfc50bfa82f5a8e509b918" name="af33d0b51c3bfc50bfa82f5a8e509b918"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af33d0b51c3bfc50bfa82f5a8e509b918">&#9670;&#160;</a></span>IDeviceMemory() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LiteFX::Rendering::IDeviceMemory::IDeviceMemory </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7b28ad410caee3b9eb9572c089eac2ad" name="a7b28ad410caee3b9eb9572c089eac2ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b28ad410caee3b9eb9572c089eac2ad">&#9670;&#160;</a></span>IDeviceMemory() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LiteFX::Rendering::IDeviceMemory::IDeviceMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_device_memory.html">IDeviceMemory</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae7240fbd1a6fff2ce3d097a8c9e27c13" name="ae7240fbd1a6fff2ce3d097a8c9e27c13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7240fbd1a6fff2ce3d097a8c9e27c13">&#9670;&#160;</a></span>IDeviceMemory() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LiteFX::Rendering::IDeviceMemory::IDeviceMemory </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_device_memory.html">IDeviceMemory</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1899194e7d61373406c922cc5b336007" name="a1899194e7d61373406c922cc5b336007"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1899194e7d61373406c922cc5b336007">&#9670;&#160;</a></span>~IDeviceMemory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual LiteFX::Rendering::IDeviceMemory::~IDeviceMemory </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a379a3fbcd746e43f6c34f26f97e01b7c" name="a379a3fbcd746e43f6c34f26f97e01b7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a379a3fbcd746e43f6c34f26f97e01b7c">&#9670;&#160;</a></span>alignedElementSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t LiteFX::Rendering::IDeviceMemory::alignedElementSize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the actual size of the element in device memory. </p>
<p>For images, this method will return a value that equals the result of <a class="el" href="#a66f85883ca87702a04035e1e51af0e53" title="Gets the size (in bytes) of the aligned memory chunk.">size</a>, aligned by <a class="el" href="#a992a32832746ca4f328711e9c924a5bd" title="Returns the alignment of a single element.">elementAlignment</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>The actual size of the element in device memory.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a992a32832746ca4f328711e9c924a5bd" title="Returns the alignment of a single element.">elementAlignment</a>, <a class="el" href="#a0f5bc5ff213aca68d049a18c995d3ef5" title="Returns the size of a single element within the buffer. If there is only one element,...">elementSize</a></dd></dl>

<p>Implemented in <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_direct_x12_buffer.html#a6a22f25fed5078e68d18889bee17e787">LiteFX::Rendering::Backends::DirectX12Buffer</a>, <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_direct_x12_image.html#a19046e51bf0ac343842590f9dcabb808">LiteFX::Rendering::Backends::DirectX12Image</a>, <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_vulkan_buffer.html#a1ecd7ee6c24f4cefb02dce466a45840c">LiteFX::Rendering::Backends::VulkanBuffer</a>, and <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_vulkan_image.html#a66589675180f4a5e803a469617a46d45">LiteFX::Rendering::Backends::VulkanImage</a>.</p>

</div>
</div>
<a id="a992a32832746ca4f328711e9c924a5bd" name="a992a32832746ca4f328711e9c924a5bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a992a32832746ca4f328711e9c924a5bd">&#9670;&#160;</a></span>elementAlignment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t LiteFX::Rendering::IDeviceMemory::elementAlignment </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the alignment of a single element. </p>
<dl class="section return"><dt>Returns</dt><dd>The alignment of a single element.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a0f5bc5ff213aca68d049a18c995d3ef5" title="Returns the size of a single element within the buffer. If there is only one element,...">elementSize</a>, <a class="el" href="#a379a3fbcd746e43f6c34f26f97e01b7c" title="Returns the actual size of the element in device memory.">alignedElementSize</a></dd></dl>

<p>Implemented in <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_direct_x12_buffer.html#ad2e19ea78d210a0b48c9fecb06e0ecde">LiteFX::Rendering::Backends::DirectX12Buffer</a>, <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_direct_x12_image.html#a92e464fb92f56317de94ae048b22f3cc">LiteFX::Rendering::Backends::DirectX12Image</a>, <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_vulkan_buffer.html#adbdcac31f8ae4a5b33f05dc718de36d1">LiteFX::Rendering::Backends::VulkanBuffer</a>, and <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_vulkan_image.html#a0495beec8b826e256913c53d5bd13056">LiteFX::Rendering::Backends::VulkanImage</a>.</p>

</div>
</div>
<a id="a9aa9ff724ffbd7864ac58e4edb414c46" name="a9aa9ff724ffbd7864ac58e4edb414c46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aa9ff724ffbd7864ac58e4edb414c46">&#9670;&#160;</a></span>elements()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a> LiteFX::Rendering::IDeviceMemory::elements </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of sub-resources inside the memory chunk. </p>
<p>For buffers, this equals the number of array elements. For images, this equals the product of layers, levels and planes. This number represents the number of states, that can be obtained by calling the state method. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of array elements inside the memory chunk.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>state</dd></dl>

<p>Implemented in <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_direct_x12_buffer.html#ace9cb8c5a568d3483951e55335715878">LiteFX::Rendering::Backends::DirectX12Buffer</a>, <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_direct_x12_image.html#aa0ae55f97314b31c062385c1ad971d4c">LiteFX::Rendering::Backends::DirectX12Image</a>, <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_vulkan_buffer.html#a61ada4eba481aec695565d55aeb8a67e">LiteFX::Rendering::Backends::VulkanBuffer</a>, and <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_vulkan_image.html#a8e31325fc16893e3c383de47516fe879">LiteFX::Rendering::Backends::VulkanImage</a>.</p>

</div>
</div>
<a id="a0f5bc5ff213aca68d049a18c995d3ef5" name="a0f5bc5ff213aca68d049a18c995d3ef5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f5bc5ff213aca68d049a18c995d3ef5">&#9670;&#160;</a></span>elementSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t LiteFX::Rendering::IDeviceMemory::elementSize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of a single element within the buffer. If there is only one element, this is equal to <a class="el" href="#a66f85883ca87702a04035e1e51af0e53" title="Gets the size (in bytes) of the aligned memory chunk.">size</a>. </p>
<p>For images, this method will return a value that equals the result of <a class="el" href="#a66f85883ca87702a04035e1e51af0e53" title="Gets the size (in bytes) of the aligned memory chunk.">size</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>The size of a single element within the buffer</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a992a32832746ca4f328711e9c924a5bd" title="Returns the alignment of a single element.">elementAlignment</a>, <a class="el" href="#a379a3fbcd746e43f6c34f26f97e01b7c" title="Returns the actual size of the element in device memory.">alignedElementSize</a></dd></dl>

<p>Implemented in <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_direct_x12_buffer.html#a563ba1024025aea33aacc36f9b429998">LiteFX::Rendering::Backends::DirectX12Buffer</a>, <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_direct_x12_image.html#aedee9f39c16f55b2621a7366a7a8ce3e">LiteFX::Rendering::Backends::DirectX12Image</a>, <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_vulkan_buffer.html#a458617b7a58e8d9973735c9e70d829e4">LiteFX::Rendering::Backends::VulkanBuffer</a>, and <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_vulkan_image.html#a3d83bc230fe340b6af370f65f71d416d">LiteFX::Rendering::Backends::VulkanImage</a>.</p>

</div>
</div>
<a id="a883e0fd5eb6bb4460649e0a7114ec0cc" name="a883e0fd5eb6bb4460649e0a7114ec0cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a883e0fd5eb6bb4460649e0a7114ec0cc">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_device_memory.html">IDeviceMemory</a> &amp; LiteFX::Rendering::IDeviceMemory::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_device_memory.html">IDeviceMemory</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a49e7c333b36dda5742cef529abef1ef3" name="a49e7c333b36dda5742cef529abef1ef3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49e7c333b36dda5742cef529abef1ef3">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_device_memory.html">IDeviceMemory</a> &amp; LiteFX::Rendering::IDeviceMemory::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_device_memory.html">IDeviceMemory</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a66f85883ca87702a04035e1e51af0e53" name="a66f85883ca87702a04035e1e51af0e53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66f85883ca87702a04035e1e51af0e53">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t LiteFX::Rendering::IDeviceMemory::size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the size (in bytes) of the aligned memory chunk. </p>
<p>The size of the device memory block depends on different factors. The actual used memory of one element can be obtained by calling by the <a class="el" href="#a0f5bc5ff213aca68d049a18c995d3ef5" title="Returns the size of a single element within the buffer. If there is only one element,...">elementSize</a>. For different reasons, though, elements may be required to be aligned to a certain size. The size of one aligned element is returned by <a class="el" href="#a379a3fbcd746e43f6c34f26f97e01b7c" title="Returns the actual size of the element in device memory.">alignedElementSize</a>. The size of the memory block, the elements get aligned to is returned by <a class="el" href="#a992a32832746ca4f328711e9c924a5bd" title="Returns the alignment of a single element.">elementAlignment</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>The size (in bytes) of the memory chunk.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a9aa9ff724ffbd7864ac58e4edb414c46" title="Gets the number of sub-resources inside the memory chunk.">elements</a>, <a class="el" href="#a0f5bc5ff213aca68d049a18c995d3ef5" title="Returns the size of a single element within the buffer. If there is only one element,...">elementSize</a>, <a class="el" href="#a992a32832746ca4f328711e9c924a5bd" title="Returns the alignment of a single element.">elementAlignment</a>, <a class="el" href="#a379a3fbcd746e43f6c34f26f97e01b7c" title="Returns the actual size of the element in device memory.">alignedElementSize</a></dd></dl>

<p>Implemented in <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_direct_x12_buffer.html#a705925c8a4f36694986bd68b904742d6">LiteFX::Rendering::Backends::DirectX12Buffer</a>, <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_direct_x12_image.html#a33978ac1c6a226d57e3f9aa9aa3680df">LiteFX::Rendering::Backends::DirectX12Image</a>, <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_vulkan_buffer.html#aac06721d7ea1bff51269de9f216bbed4">LiteFX::Rendering::Backends::VulkanBuffer</a>, <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_vulkan_image.html#a607a12a439c046293413b5af9040f634">LiteFX::Rendering::Backends::VulkanImage</a>, and <a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_image.html#a66f85883ca87702a04035e1e51af0e53">LiteFX::Rendering::IImage</a>.</p>

</div>
</div>
<a id="a0f597c3eecfe5e4d6909bd67ad962e64" name="a0f597c3eecfe5e4d6909bd67ad962e64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f597c3eecfe5e4d6909bd67ad962e64">&#9670;&#160;</a></span>usage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespace_lite_f_x_1_1_rendering.html#a85e85c2c13e89d1aaadc8dcfad380951">ResourceUsage</a> LiteFX::Rendering::IDeviceMemory::usage </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the usage flags for the resource. </p>
<dl class="section return"><dt>Returns</dt><dd>The usage flags for the resource.</dd></dl>

<p>Implemented in <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_direct_x12_buffer.html#af91f89c4eec658f1212d8adb42414905">LiteFX::Rendering::Backends::DirectX12Buffer</a>, <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_direct_x12_image.html#a70946065de77014f733c28fc9cab50f7">LiteFX::Rendering::Backends::DirectX12Image</a>, <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_vulkan_buffer.html#a281ad9c79c2ba01ab3e277006db3c51f">LiteFX::Rendering::Backends::VulkanBuffer</a>, and <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_vulkan_image.html#ab9ac5fa964afae6a2cf958684609763d">LiteFX::Rendering::Backends::VulkanImage</a>.</p>

</div>
</div>
<a id="a7e19d686770eb7c6f847e8f2ce78c79b" name="a7e19d686770eb7c6f847e8f2ce78c79b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e19d686770eb7c6f847e8f2ce78c79b">&#9670;&#160;</a></span>virtualAddress()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespace_lite_f_x_1_1_math.html#a42c7bab2ce6b3575c6e1316cd87de457">UInt64</a> LiteFX::Rendering::IDeviceMemory::virtualAddress </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the address of the resource in GPU memory. </p>
<p>Note that this may not be supported for all resource types in all backends. For example, Vulkan does not support obtaining virtual addresses of image resources. </p>
<dl class="section return"><dt>Returns</dt><dd>The address of the resource in GPU memory.</dd></dl>

<p>Implemented in <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_direct_x12_buffer.html#acd725ff821aeb3049cf89a14ede9c492">LiteFX::Rendering::Backends::DirectX12Buffer</a>, <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_direct_x12_image.html#a8e654eae46a7e64a4c883171f40c962f">LiteFX::Rendering::Backends::DirectX12Image</a>, <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_vulkan_buffer.html#a9c286d746cf7e2a6d22b43a02233c704">LiteFX::Rendering::Backends::VulkanBuffer</a>, and <a class="el" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_vulkan_image.html#a8d464b547c7b46447ab47b34b9820b5c">LiteFX::Rendering::Backends::VulkanImage</a>.</p>

</div>
</div>
<a id="a91f22c38dfa49a8fa39a55ca0feb38cb" name="a91f22c38dfa49a8fa39a55ca0feb38cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91f22c38dfa49a8fa39a55ca0feb38cb">&#9670;&#160;</a></span>volatileMove()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool LiteFX::Rendering::IDeviceMemory::volatileMove </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code>, if the contents of the resource should not be copied during a move. </p>
<p>To set this flag, include <a class="el" href="namespace_lite_f_x_1_1_rendering.html#a85e85c2c13e89d1aaadc8dcfad380951a3e3af98b6b48c7e593d8d18863e3333b" title="Causes the contents of the resource to not be copied during defragmentation.">ResourceUsage::Volatile</a> in the resource usage flags. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code>, if the contents of the resource should not be copied during a move and <code>false</code> otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#af0e56fb490b2ff583d559e5099af5916" title="An event that gets invoked before a resource is copied during a move.">moving</a>, <a class="el" href="#a0f597c3eecfe5e4d6909bd67ad962e64" title="Returns the usage flags for the resource.">usage</a>, <a class="el" href="namespace_lite_f_x_1_1_rendering.html#a85e85c2c13e89d1aaadc8dcfad380951a3e3af98b6b48c7e593d8d18863e3333b" title="Causes the contents of the resource to not be copied during defragmentation.">ResourceUsage::Volatile</a></dd></dl>

</div>
</div>
<a id="a8cec9d7f1ee29d0f088d16b31cd3bb3e" name="a8cec9d7f1ee29d0f088d16b31cd3bb3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cec9d7f1ee29d0f088d16b31cd3bb3e">&#9670;&#160;</a></span>writable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool LiteFX::Rendering::IDeviceMemory::writable </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code>, if the resource can be bound to a read/write descriptor. </p>
<p>If the resource is not writable, attempting to bind it to a writable descriptor will result in an exception. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code>, if the resource can be bound to a read/write descriptor.</dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ae935df7a7d5ecaff70e7fbc7b974b477" name="ae935df7a7d5ecaff70e7fbc7b974b477"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae935df7a7d5ecaff70e7fbc7b974b477">&#9670;&#160;</a></span>moved</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_lite_f_x_1_1_event.html">Event</a>&lt;<a class="el" href="class_lite_f_x_1_1_event_args.html">EventArgs</a>&gt; LiteFX::Rendering::IDeviceMemory::moved</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An event that gets invoked, after the resource has been moved to a different location, but before the old resource gets destroyed. </p>
<p>This event gets invoked during defragmentation to inform any subscribers about a relocation. You might want to subscribe to this event is to update any descriptor bindings, as they become invalid after the previous resource gets removed. Additionally, you may want to insert barriers to transition the resource back into the desired layout.</p>
<p>Note that this event is invoked on the thread that executes the defragmentation process, which means you potentially might want to synchronize the handler with other resource accesses. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#af0e56fb490b2ff583d559e5099af5916" title="An event that gets invoked before a resource is copied during a move.">moving</a>, IGraphicsFactory::defragment</dd></dl>

</div>
</div>
<a id="af0e56fb490b2ff583d559e5099af5916" name="af0e56fb490b2ff583d559e5099af5916"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0e56fb490b2ff583d559e5099af5916">&#9670;&#160;</a></span>moving</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_lite_f_x_1_1_event.html">Event</a>&lt;<a class="el" href="struct_lite_f_x_1_1_rendering_1_1_i_device_memory_1_1_resource_moving_event_args.html">ResourceMovingEventArgs</a>&gt; LiteFX::Rendering::IDeviceMemory::moving</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An event that gets invoked before a resource is copied during a move. </p>
<p>This event gets invoked during defragmentation to inform any subscribers about the relocation. Moving a resource involves an asynchronous copy-command. This event is invoked after this command has been submitted, but before it has been executed. The <a class="el" href="#ae935df7a7d5ecaff70e7fbc7b974b477" title="An event that gets invoked, after the resource has been moved to a different location,...">moved</a> event executes after the resource has been copied to the new location.</p>
<p>Note that this event is invoked on the thread that executes the defragmentation process, which means you potentially might want to synchronize the handler with other potential resource accesses. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ae935df7a7d5ecaff70e7fbc7b974b477" title="An event that gets invoked, after the resource has been moved to a different location,...">moved</a>, IGraphicsFactory::defragment</dd></dl>

</div>
</div>
<a id="a127e1e946d18d05dabb385d5df0aa29d" name="a127e1e946d18d05dabb385d5df0aa29d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a127e1e946d18d05dabb385d5df0aa29d">&#9670;&#160;</a></span>prepareMove</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_lite_f_x_1_1_event.html">Event</a>&lt;const <a class="el" href="struct_lite_f_x_1_1_rendering_1_1_i_device_memory_1_1_prepare_move_event_args.html">PrepareMoveEventArgs</a>&amp;&gt; LiteFX::Rendering::IDeviceMemory::prepareMove</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An event that gets invoked to prepare a resource for a move operation. </p>
<p>The purpose of this event is to prepare a barrier that synchronizes the resource with other accesses. The event arguments of this event contain a reference to a barrier instance, that can be used to insert a barrier for the resource. Note that the transition must be supported on the underlying command queue that executes the move.</p>
<p>Note that both, the DirectX 12 as well as the Vulkan backend expect images to be in <a class="el" href="namespace_lite_f_x_1_1_rendering.html#a190ea10dd0d34250e0efc1b42ba3f85aad13bc5b68b2bd9e18f29777db17cc563" title="A common image layout that allows for all types of access (shader resource, transfer destination,...">ImageLayout::Common</a> layout before moving them. </p>
<dl class="section see"><dt>See also</dt><dd>IGraphicsFactory::defragment</dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_lite_f_x.html">LiteFX</a></li><li class="navelem"><a class="el" href="namespace_lite_f_x_1_1_rendering.html">Rendering</a></li><li class="navelem"><a class="el" href="class_lite_f_x_1_1_rendering_1_1_i_device_memory.html">IDeviceMemory</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
