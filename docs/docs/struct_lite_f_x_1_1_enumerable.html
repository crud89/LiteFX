<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LiteFX: LiteFX::Enumerable&lt; T &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="theme.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">LiteFX<span id="projectnumber">&#160;0.4.2.2025</span>
   </div>
   <div id="projectbrief">Computer Graphics Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('struct_lite_f_x_1_1_enumerable.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="struct_lite_f_x_1_1_enumerable-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">LiteFX::Enumerable&lt; T &gt; Struct Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>An input range over another range, where the returned values of type <em>T</em>  are covariants of the values stored by the underlying range.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="containers_8hpp_source.html">containers.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ade2f28821a60798fc09385b39f854ae1" id="r_ade2f28821a60798fc09385b39f854ae1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade2f28821a60798fc09385b39f854ae1">value_type</a> = std::remove_cvref_t&lt;T&gt;</td></tr>
<tr class="memdesc:ade2f28821a60798fc09385b39f854ae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the value that is contained by the <code><a class="el" href="struct_lite_f_x_1_1_enumerable.html" title="An input range over another range, where the returned values of type T  are covariants of the values ...">Enumerable</a></code>.  <br /></td></tr>
<tr class="separator:ade2f28821a60798fc09385b39f854ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57b757a72f8a22d47c4941aaa078a44c" id="r_a57b757a72f8a22d47c4941aaa078a44c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a57b757a72f8a22d47c4941aaa078a44c">pointer</a> = std::remove_reference_t&lt;T&gt;*</td></tr>
<tr class="memdesc:a57b757a72f8a22d47c4941aaa078a44c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a pointer returned by the <code><a class="el" href="struct_lite_f_x_1_1_enumerable.html" title="An input range over another range, where the returned values of type T  are covariants of the values ...">Enumerable</a></code>.  <br /></td></tr>
<tr class="separator:a57b757a72f8a22d47c4941aaa078a44c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4163eba64ea138f9148b69f02f1e4d2" id="r_aa4163eba64ea138f9148b69f02f1e4d2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa4163eba64ea138f9148b69f02f1e4d2">reference</a> = std::remove_reference_t&lt;T&gt;&amp;</td></tr>
<tr class="memdesc:aa4163eba64ea138f9148b69f02f1e4d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a reference returned by the <code><a class="el" href="struct_lite_f_x_1_1_enumerable.html" title="An input range over another range, where the returned values of type T  are covariants of the values ...">Enumerable</a></code>.  <br /></td></tr>
<tr class="separator:aa4163eba64ea138f9148b69f02f1e4d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a485754a34841172230deb57523d8693f" id="r_a485754a34841172230deb57523d8693f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a485754a34841172230deb57523d8693f">iterator</a> = <a class="el" href="struct_lite_f_x_1_1_covariant_iterator.html">CovariantIterator</a>&lt;T&gt;</td></tr>
<tr class="memdesc:a485754a34841172230deb57523d8693f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the iterator used to iterate the elements of the <code><a class="el" href="struct_lite_f_x_1_1_enumerable.html" title="An input range over another range, where the returned values of type T  are covariants of the values ...">Enumerable</a></code>.  <br /></td></tr>
<tr class="separator:a485754a34841172230deb57523d8693f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0d65e74439dc10b4975c19886724e98" id="r_ae0d65e74439dc10b4975c19886724e98"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae0d65e74439dc10b4975c19886724e98">const_iterator</a> = <a class="el" href="struct_lite_f_x_1_1_covariant_iterator.html">CovariantIterator</a>&lt;const std::remove_const_t&lt;T&gt;&gt;</td></tr>
<tr class="memdesc:ae0d65e74439dc10b4975c19886724e98"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the iterator used to iterate constant elements of the <code><a class="el" href="struct_lite_f_x_1_1_enumerable.html" title="An input range over another range, where the returned values of type T  are covariants of the values ...">Enumerable</a></code>.  <br /></td></tr>
<tr class="separator:ae0d65e74439dc10b4975c19886724e98"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afa725783e2676743edca379be5c8356b" id="r_afa725783e2676743edca379be5c8356b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa725783e2676743edca379be5c8356b">Enumerable</a> ()</td></tr>
<tr class="memdesc:afa725783e2676743edca379be5c8356b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an enumerable over an empty range.  <br /></td></tr>
<tr class="separator:afa725783e2676743edca379be5c8356b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67ca5ebe10303fef852b5409a8f476ed" id="r_a67ca5ebe10303fef852b5409a8f476ed"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a67ca5ebe10303fef852b5409a8f476ed">Enumerable</a> (const <a class="el" href="struct_lite_f_x_1_1_enumerable.html">Enumerable</a> &amp;range)=default</td></tr>
<tr class="separator:a67ca5ebe10303fef852b5409a8f476ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa05050419d6415fc70ddb2235d37bfa2" id="r_aa05050419d6415fc70ddb2235d37bfa2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa05050419d6415fc70ddb2235d37bfa2">Enumerable</a> (<a class="el" href="struct_lite_f_x_1_1_enumerable.html">Enumerable</a> &amp;&amp;range) noexcept=default</td></tr>
<tr class="separator:aa05050419d6415fc70ddb2235d37bfa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76a7c65fa3fb6f8ac949d16c2c5580f3" id="r_a76a7c65fa3fb6f8ac949d16c2c5580f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_lite_f_x_1_1_enumerable.html">Enumerable</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a76a7c65fa3fb6f8ac949d16c2c5580f3">operator=</a> (const <a class="el" href="struct_lite_f_x_1_1_enumerable.html">Enumerable</a> &amp;range)=default</td></tr>
<tr class="separator:a76a7c65fa3fb6f8ac949d16c2c5580f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a070a1e6711eb76332d341b6cd898ee7a" id="r_a070a1e6711eb76332d341b6cd898ee7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_lite_f_x_1_1_enumerable.html">Enumerable</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a070a1e6711eb76332d341b6cd898ee7a">operator=</a> (<a class="el" href="struct_lite_f_x_1_1_enumerable.html">Enumerable</a> &amp;&amp;range) noexcept=default</td></tr>
<tr class="separator:a070a1e6711eb76332d341b6cd898ee7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41d842bd4324346922381df84b37869c" id="r_a41d842bd4324346922381df84b37869c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a41d842bd4324346922381df84b37869c">~Enumerable</a> () noexcept=default</td></tr>
<tr class="separator:a41d842bd4324346922381df84b37869c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07d67c721551649af7dfb0b33cfe6a8d" id="r_a07d67c721551649af7dfb0b33cfe6a8d"><td class="memTemplParams" colspan="2">template&lt;typename TRange , typename enabled  = std::enable_if_t&lt;!std::is_same_v&lt;TRange, Enumerable&gt;&gt;&gt; </td></tr>
<tr class="memitem:a07d67c721551649af7dfb0b33cfe6a8d"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a07d67c721551649af7dfb0b33cfe6a8d">Enumerable</a> (TRange &amp;&amp;range)</td></tr>
<tr class="memdesc:a07d67c721551649af7dfb0b33cfe6a8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <code><a class="el" href="struct_lite_f_x_1_1_enumerable.html" title="An input range over another range, where the returned values of type T  are covariants of the values ...">Enumerable</a></code> instance from an underlying range.  <br /></td></tr>
<tr class="separator:a07d67c721551649af7dfb0b33cfe6a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a371eb822f2b592edabec1dfc6863f632" id="r_a371eb822f2b592edabec1dfc6863f632"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a371eb822f2b592edabec1dfc6863f632">begin</a> () const</td></tr>
<tr class="memdesc:a371eb822f2b592edabec1dfc6863f632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the start of the underlying range.  <br /></td></tr>
<tr class="separator:a371eb822f2b592edabec1dfc6863f632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f2f3f76c795baa11559953a63a6643c" id="r_a7f2f3f76c795baa11559953a63a6643c"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f2f3f76c795baa11559953a63a6643c">end</a> () const</td></tr>
<tr class="memdesc:a7f2f3f76c795baa11559953a63a6643c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the end of the underlying range.  <br /></td></tr>
<tr class="separator:a7f2f3f76c795baa11559953a63a6643c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aead100a21c01c857ad78f0441500005d" id="r_aead100a21c01c857ad78f0441500005d"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aead100a21c01c857ad78f0441500005d">cbegin</a> () const</td></tr>
<tr class="memdesc:aead100a21c01c857ad78f0441500005d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator pointing to the start of the underlying range.  <br /></td></tr>
<tr class="separator:aead100a21c01c857ad78f0441500005d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e93146be4ee68dd466b44fdce0aec93" id="r_a4e93146be4ee68dd466b44fdce0aec93"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e93146be4ee68dd466b44fdce0aec93">cend</a> () const</td></tr>
<tr class="memdesc:a4e93146be4ee68dd466b44fdce0aec93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator pointing to the end of the underlying range.  <br /></td></tr>
<tr class="separator:a4e93146be4ee68dd466b44fdce0aec93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ada095e9fa4c9c16cc259d0658db639" id="r_a6ada095e9fa4c9c16cc259d0658db639"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ada095e9fa4c9c16cc259d0658db639">empty</a> () const noexcept</td></tr>
<tr class="memdesc:a6ada095e9fa4c9c16cc259d0658db639"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code>, if there are no elements inside the <code><a class="el" href="struct_lite_f_x_1_1_enumerable.html" title="An input range over another range, where the returned values of type T  are covariants of the values ...">Enumerable</a></code> and <code>false</code> otherwise.  <br /></td></tr>
<tr class="separator:a6ada095e9fa4c9c16cc259d0658db639"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T&gt;<br />
struct LiteFX::Enumerable&lt; T &gt;</div><p>An input range over another range, where the returned values of type <em>T</em>  are covariants of the values stored by the underlying range. </p>
<p>An <code><a class="el" href="struct_lite_f_x_1_1_enumerable.html" title="An input range over another range, where the returned values of type T  are covariants of the values ...">Enumerable</a></code> is intended to be used as a covariant input range for interfaces that want to expose a range of elements that are also interfaces for the stored elements of the actual range. In the context of an <code><a class="el" href="struct_lite_f_x_1_1_enumerable.html" title="An input range over another range, where the returned values of type T  are covariants of the values ...">Enumerable</a></code>, <em>covariance</em> refers to the type <em>T</em>  either being assignable or constructible from the underlying range value type. This allows not only derived types (in a stricter definition that the C++ language standard uses), but also unrelated types, such as smart pointers to be used in a covariant fashion.</p>
<p>In the following example, the interface <code>IContainer</code> returns an <code><a class="el" href="struct_lite_f_x_1_1_enumerable.html" title="An input range over another range, where the returned values of type T  are covariants of the values ...">Enumerable</a>&amp;lt;IContained&amp;gt;</code> from a class <code>Container</code>, where the contained elements are of type <code>Contained</code>.</p>
<p>class IContained { }; class Contained : public IContained { };</p>
<p>class IContainer { public: virtual Enumerable&lt;const IContained&amp;&gt; elements() const noexcept = 0; };</p>
<p>class Container : public IContainer { private: std::vector&lt;Contained&gt; _elements;</p>
<p>public: Enumerable&lt;const IContained&amp;&gt; elements() const noexcept override { return _elements; } }; </p>
<p>As <code>Contained</code> is derived from <code>IContained</code>, they are covariant in terms of the language. In the context of <code><a class="el" href="struct_lite_f_x_1_1_enumerable.html" title="An input range over another range, where the returned values of type T  are covariants of the values ...">Enumerable</a></code>, they are covariant, because a <code>const IContained&amp;amp;</code> can be constructed from a <code>const Contained&amp;amp;</code>. This way, using <code>Enumeable</code> in <code>IContainer</code> allows to iterate the interface instances without knowing their type when declaring the interface. The covariance relation only applies to the elements of the range, not the range itself. In the example above, <code>std::vector&amp;lt;Contained&amp;gt;</code> is not covariant to <code><a class="el" href="struct_lite_f_x_1_1_enumerable.html" title="An input range over another range, where the returned values of type T  are covariants of the values ...">Enumerable</a>&amp;lt;const IContained&amp;gt;</code>, as the two types are not related. This is important as <code><a class="el" href="struct_lite_f_x_1_1_enumerable.html" title="An input range over another range, where the returned values of type T  are covariants of the values ...">Enumerable</a></code> has a slight performance impact compared to returning a reference of the underlying range directly, both in terms of memory (it stores type information about the original iterators) as well as runtime (it requires a virtual call for iterator increments, dereferencing and comparison). If you want to expose covariant ranges in interfaces, but allow for maximum performance when the implementation is called directly, you can hide the interface method using private inheritance:</p>
<p>class IContainer { public: inline Enumerable&lt;const IContained&amp;&gt; elements() const noexcept { return this-&gt;getElements(); }</p>
<p>private: virtual Enumerable&lt;const IContained&amp;&gt; getElements() const noexcept = 0; };</p>
<p>class Container : public IContainer { private: std::vector&lt;Contained&gt; _elements;</p>
<p>public: const std::vector&lt;IContained&gt;&amp; elements() const noexcept { return _elements; }</p>
<p>private: Enumerable&lt;const IContained&amp;&gt; getElements() const noexcept override { return _elements; } }; </p>
<p><code><a class="el" href="struct_lite_f_x_1_1_enumerable.html" title="An input range over another range, where the returned values of type T  are covariants of the values ...">Enumerable</a></code> can be using in two ways: first, it can be initialized with a lvalue reference of the underlying range or view as shown above. In this case, only the begin and end iterators of the underlying range are stored. However, when passed a rvalue reference, the <code><a class="el" href="struct_lite_f_x_1_1_enumerable.html" title="An input range over another range, where the returned values of type T  are covariants of the values ...">Enumerable</a></code> will store the underlying range until it and all copies of it are destroyed. This allows to use <code><a class="el" href="struct_lite_f_x_1_1_enumerable.html" title="An input range over another range, where the returned values of type T  are covariants of the values ...">Enumerable</a></code> either for returning a temporary range or a view as shown in the example below.</p>
<p>Enumerable&lt;Foo&gt; temporaryFoos() { std::vector&lt;Foo&gt; foos {}; foos.emplace_back(); foos.emplace_back(); foos.emplace_back();</p>
<p>return std::move(foos);</p>
<p>// Or better: //return std::vector&lt;Foo&gt;(3); }</p>
<p>Enumerable&lt;Foo&amp;&gt; filteredFoos(const std::vector&lt;Foo&gt;&amp; foos) { return foos | std::views::drop(1) | std::views::take(2); } </p>
<p>Keep in mind that the type parameter <em>T</em>  dictates what an iterator returns from the <code><a class="el" href="struct_lite_f_x_1_1_enumerable.html" title="An input range over another range, where the returned values of type T  are covariants of the values ...">Enumerable</a></code>, i.e. if an lvalue or (p)rvalue should be returned and wheather or not a copy is created accordingly. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the values returned by the enumerable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_lite_f_x_1_1_covariant_iterator.html" title="Wraps an iterator and returns covariants of type T  of the iterated value.">CovariantIterator</a></dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ae0d65e74439dc10b4975c19886724e98" name="ae0d65e74439dc10b4975c19886724e98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0d65e74439dc10b4975c19886724e98">&#9670;&#160;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="struct_lite_f_x_1_1_enumerable.html">LiteFX::Enumerable</a>&lt; T &gt;::const_iterator = <a class="el" href="struct_lite_f_x_1_1_covariant_iterator.html">CovariantIterator</a>&lt;const std::remove_const_t&lt;T&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the iterator used to iterate constant elements of the <code><a class="el" href="struct_lite_f_x_1_1_enumerable.html" title="An input range over another range, where the returned values of type T  are covariants of the values ...">Enumerable</a></code>. </p>

</div>
</div>
<a id="a485754a34841172230deb57523d8693f" name="a485754a34841172230deb57523d8693f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a485754a34841172230deb57523d8693f">&#9670;&#160;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="struct_lite_f_x_1_1_enumerable.html">LiteFX::Enumerable</a>&lt; T &gt;::iterator = <a class="el" href="struct_lite_f_x_1_1_covariant_iterator.html">CovariantIterator</a>&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the iterator used to iterate the elements of the <code><a class="el" href="struct_lite_f_x_1_1_enumerable.html" title="An input range over another range, where the returned values of type T  are covariants of the values ...">Enumerable</a></code>. </p>

</div>
</div>
<a id="a57b757a72f8a22d47c4941aaa078a44c" name="a57b757a72f8a22d47c4941aaa078a44c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57b757a72f8a22d47c4941aaa078a44c">&#9670;&#160;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="struct_lite_f_x_1_1_enumerable.html">LiteFX::Enumerable</a>&lt; T &gt;::pointer = std::remove_reference_t&lt;T&gt;*</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of a pointer returned by the <code><a class="el" href="struct_lite_f_x_1_1_enumerable.html" title="An input range over another range, where the returned values of type T  are covariants of the values ...">Enumerable</a></code>. </p>

</div>
</div>
<a id="aa4163eba64ea138f9148b69f02f1e4d2" name="aa4163eba64ea138f9148b69f02f1e4d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4163eba64ea138f9148b69f02f1e4d2">&#9670;&#160;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="struct_lite_f_x_1_1_enumerable.html">LiteFX::Enumerable</a>&lt; T &gt;::reference = std::remove_reference_t&lt;T&gt;&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of a reference returned by the <code><a class="el" href="struct_lite_f_x_1_1_enumerable.html" title="An input range over another range, where the returned values of type T  are covariants of the values ...">Enumerable</a></code>. </p>

</div>
</div>
<a id="ade2f28821a60798fc09385b39f854ae1" name="ade2f28821a60798fc09385b39f854ae1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade2f28821a60798fc09385b39f854ae1">&#9670;&#160;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="struct_lite_f_x_1_1_enumerable.html">LiteFX::Enumerable</a>&lt; T &gt;::value_type = std::remove_cvref_t&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the value that is contained by the <code><a class="el" href="struct_lite_f_x_1_1_enumerable.html" title="An input range over another range, where the returned values of type T  are covariants of the values ...">Enumerable</a></code>. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="afa725783e2676743edca379be5c8356b" name="afa725783e2676743edca379be5c8356b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa725783e2676743edca379be5c8356b">&#9670;&#160;</a></span>Enumerable() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_lite_f_x_1_1_enumerable.html">LiteFX::Enumerable</a>&lt; T &gt;::Enumerable </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an enumerable over an empty range. </p>

</div>
</div>
<a id="a67ca5ebe10303fef852b5409a8f476ed" name="a67ca5ebe10303fef852b5409a8f476ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67ca5ebe10303fef852b5409a8f476ed">&#9670;&#160;</a></span>Enumerable() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_lite_f_x_1_1_enumerable.html">LiteFX::Enumerable</a>&lt; T &gt;::Enumerable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_lite_f_x_1_1_enumerable.html">Enumerable</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>range</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa05050419d6415fc70ddb2235d37bfa2" name="aa05050419d6415fc70ddb2235d37bfa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa05050419d6415fc70ddb2235d37bfa2">&#9670;&#160;</a></span>Enumerable() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_lite_f_x_1_1_enumerable.html">LiteFX::Enumerable</a>&lt; T &gt;::Enumerable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_lite_f_x_1_1_enumerable.html">Enumerable</a>&lt; T &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>range</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a41d842bd4324346922381df84b37869c" name="a41d842bd4324346922381df84b37869c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41d842bd4324346922381df84b37869c">&#9670;&#160;</a></span>~Enumerable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_lite_f_x_1_1_enumerable.html">LiteFX::Enumerable</a>&lt; T &gt;::~<a class="el" href="struct_lite_f_x_1_1_enumerable.html">Enumerable</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a07d67c721551649af7dfb0b33cfe6a8d" name="a07d67c721551649af7dfb0b33cfe6a8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07d67c721551649af7dfb0b33cfe6a8d">&#9670;&#160;</a></span>Enumerable() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename TRange , typename enabled  = std::enable_if_t&lt;!std::is_same_v&lt;TRange, Enumerable&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_lite_f_x_1_1_enumerable.html">LiteFX::Enumerable</a>&lt; T &gt;::Enumerable </td>
          <td>(</td>
          <td class="paramtype">TRange &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>range</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <code><a class="el" href="struct_lite_f_x_1_1_enumerable.html" title="An input range over another range, where the returned values of type T  are covariants of the values ...">Enumerable</a></code> instance from an underlying range. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TRange</td><td>The type of the underlying range.</td></tr>
    <tr><td class="paramname">enabled</td><td>Disables the constructor, if <em>TRange</em>  is equal to the current type, in which case the move constructor should be called.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>A reference of the underlying range.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a371eb822f2b592edabec1dfc6863f632" name="a371eb822f2b592edabec1dfc6863f632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a371eb822f2b592edabec1dfc6863f632">&#9670;&#160;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="struct_lite_f_x_1_1_enumerable.html">LiteFX::Enumerable</a>&lt; T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the start of the underlying range. </p>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the start of the underlying range.</dd></dl>

</div>
</div>
<a id="aead100a21c01c857ad78f0441500005d" name="aead100a21c01c857ad78f0441500005d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aead100a21c01c857ad78f0441500005d">&#9670;&#160;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="struct_lite_f_x_1_1_enumerable.html">LiteFX::Enumerable</a>&lt; T &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant iterator pointing to the start of the underlying range. </p>
<dl class="section return"><dt>Returns</dt><dd>A constant iterator pointing to the start of the underlying range.</dd></dl>

</div>
</div>
<a id="a4e93146be4ee68dd466b44fdce0aec93" name="a4e93146be4ee68dd466b44fdce0aec93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e93146be4ee68dd466b44fdce0aec93">&#9670;&#160;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="struct_lite_f_x_1_1_enumerable.html">LiteFX::Enumerable</a>&lt; T &gt;::cend </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant iterator pointing to the end of the underlying range. </p>
<dl class="section return"><dt>Returns</dt><dd>A constant iterator pointing to the end of the underlying range.</dd></dl>

</div>
</div>
<a id="a6ada095e9fa4c9c16cc259d0658db639" name="a6ada095e9fa4c9c16cc259d0658db639"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ada095e9fa4c9c16cc259d0658db639">&#9670;&#160;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="struct_lite_f_x_1_1_enumerable.html">LiteFX::Enumerable</a>&lt; T &gt;::empty </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code>, if there are no elements inside the <code><a class="el" href="struct_lite_f_x_1_1_enumerable.html" title="An input range over another range, where the returned values of type T  are covariants of the values ...">Enumerable</a></code> and <code>false</code> otherwise. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code>, if there are no elements inside the <code><a class="el" href="struct_lite_f_x_1_1_enumerable.html" title="An input range over another range, where the returned values of type T  are covariants of the values ...">Enumerable</a></code> and <code>false</code> otherwise.</dd></dl>

</div>
</div>
<a id="a7f2f3f76c795baa11559953a63a6643c" name="a7f2f3f76c795baa11559953a63a6643c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f2f3f76c795baa11559953a63a6643c">&#9670;&#160;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="struct_lite_f_x_1_1_enumerable.html">LiteFX::Enumerable</a>&lt; T &gt;::end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the end of the underlying range. </p>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the end of the underlying range.</dd></dl>

</div>
</div>
<a id="a76a7c65fa3fb6f8ac949d16c2c5580f3" name="a76a7c65fa3fb6f8ac949d16c2c5580f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76a7c65fa3fb6f8ac949d16c2c5580f3">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_lite_f_x_1_1_enumerable.html">Enumerable</a> &amp; <a class="el" href="struct_lite_f_x_1_1_enumerable.html">LiteFX::Enumerable</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_lite_f_x_1_1_enumerable.html">Enumerable</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>range</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a070a1e6711eb76332d341b6cd898ee7a" name="a070a1e6711eb76332d341b6cd898ee7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a070a1e6711eb76332d341b6cd898ee7a">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_lite_f_x_1_1_enumerable.html">Enumerable</a> &amp; <a class="el" href="struct_lite_f_x_1_1_enumerable.html">LiteFX::Enumerable</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_lite_f_x_1_1_enumerable.html">Enumerable</a>&lt; T &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>range</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_lite_f_x.html">LiteFX</a></li><li class="navelem"><a class="el" href="struct_lite_f_x_1_1_enumerable.html">Enumerable</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
