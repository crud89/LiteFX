<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LiteFX: Quick Start</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="theme.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">LiteFX<span id="projectnumber">&#160;0.4.2.2025</span>
   </div>
   <div id="projectbrief">Computer Graphics Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md_docs_2tutorials_2quick-start.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Quick Start</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md2"></a></p>
<p>This guide walks you through the steps required to write an application that renders a simple primitive. It demonstrates the most important features and use-cases of the <a class="el" href="namespace_lite_f_x.html">LiteFX</a> engine. Before you start, make sure you've successfully setup a project by following the <a href="md_docs_tutorials_project_setup.html">project setup guide</a>.</p>
<h1><a class="anchor" id="autotoc_md14"></a>
Application Infrastructure</h1>
<p>At the core of each application that uses <a class="el" href="namespace_lite_f_x.html">LiteFX</a> are two major concepts. First, you must define an object that inherits from <code><a class="el" href="class_lite_f_x_1_1_app.html" title="The base class for an application.">LiteFX::App</a></code>. This object manages your applications lifetime as well as backend instances. Backends are the second major concept when working with <a class="el" href="namespace_lite_f_x.html">LiteFX</a>. A backend can be any external system that is accessed through a common interface. At the moment, <a class="el" href="namespace_lite_f_x.html">LiteFX</a> only supports one type of backends (graphics backends), that are used to implement interfaces to graphics APIs. There are two backends available, one for the DirectX 12 and one for Vulkan API. The builtin backends all reside within the namespace <code><a class="el" href="namespace_lite_f_x_1_1_rendering_1_1_backends.html">LiteFX::Rendering::Backends</a></code>.</p>
<p>Before going further into detail, let's start by writing our main application header file (<code>main.h</code>). In this header file, we include every definition required to build a simple application, including the engine and <em>glfw</em> headers.</p>
<div class="fragment"><div class="line"><span class="comment">// main.h</span></div>
<div class="line"><span class="preprocessor">#pragma once</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define LITEFX_DEFINE_GLOBAL_EXPORTS</span></div>
<div class="line"><span class="preprocessor">#define LITEFX_AUTO_IMPORT_BACKEND_HEADERS</span></div>
<div class="line"><span class="preprocessor">#include &lt;litefx/litefx.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespace_lite_f_x.html">LiteFX</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespace_lite_f_x_1_1_math.html">LiteFX::Math</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespace_lite_f_x_1_1_rendering.html">LiteFX::Rendering</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespace_lite_f_x_1_1_rendering_1_1_backends.html">LiteFX::Rendering::Backends</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Include glfw.</span></div>
<div class="line"><span class="preprocessor">#if (defined _WIN32 || defined WINCE)</span></div>
<div class="line"><span class="preprocessor">#  define GLFW_EXPOSE_NATIVE_WIN32</span></div>
<div class="line"><span class="preprocessor">#else </span></div>
<div class="line"><span class="preprocessor">#  pragma message (&quot;No supported surface platform detected.&quot;)</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;GLFW/glfw3.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;GLFW/glfw3native.h&gt;</span></div>
<div class="ttc" id="anamespace_lite_f_x_1_1_math_html"><div class="ttname"><a href="namespace_lite_f_x_1_1_math.html">LiteFX::Math</a></div><div class="ttdef"><b>Definition</b> math.hpp:30</div></div>
<div class="ttc" id="anamespace_lite_f_x_1_1_rendering_1_1_backends_html"><div class="ttname"><a href="namespace_lite_f_x_1_1_rendering_1_1_backends.html">LiteFX::Rendering::Backends</a></div><div class="ttdef"><b>Definition</b> dx12.hpp:11</div></div>
<div class="ttc" id="anamespace_lite_f_x_1_1_rendering_html"><div class="ttname"><a href="namespace_lite_f_x_1_1_rendering.html">LiteFX::Rendering</a></div><div class="ttdef"><b>Definition</b> dx12.hpp:11</div></div>
<div class="ttc" id="anamespace_lite_f_x_html"><div class="ttname"><a href="namespace_lite_f_x.html">LiteFX</a></div><div class="ttdef"><b>Definition</b> app.hpp:6</div></div>
</div><!-- fragment --><p>Note that before including the core engine header, we setup two definitions:</p>
<ul>
<li><code>LITEFX_DEFINE_GLOBAL_EXPORTS</code> is required for exporting symbols that are used to pick up the D3D12 Agility SDK. If you are not using the DirectX 12 backend, or if you are providing a custom version of the SDK you can remove this macro.</li>
<li><code>LITEFX_AUTO_IMPORT_BACKEND_HEADERS</code> automatically includes the headers of all supported backends for you, so that you do not have to include them on your own.</li>
</ul>
<p><b>Important:</b> note that when you extent your application, you should not include <code>main.h</code> elsewhere. If you include the engine headers from another header, do not re-define the <code>LITEFX_DEFINE_GLOBAL_EXPORTS</code> there. The headers must be included in exactly one location when this macro is defined.</p>
<p>The next step is to define an application class that implements <code><a class="el" href="class_lite_f_x_1_1_app.html" title="The base class for an application.">LiteFX::App</a></code>. We can do this in the <code>main.cpp</code> file, but you might want to move the implementation to another location later. You can take a look at the engine samples for inspiration.</p>
<div class="fragment"><div class="line"><span class="comment">// main.cpp</span></div>
<div class="line"><span class="preprocessor">#include &quot;main.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;array&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MyApp : <span class="keyword">public</span> <a class="code hl_class" href="class_lite_f_x_1_1_app.html">LiteFX::App</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">static</span> <a class="code hl_typedef" href="namespace_lite_f_x.html#a8f67ef1b66d8e11201ba89c9db51c0c8">StringView</a> Name() noexcept { <span class="keywordflow">return</span> <span class="stringliteral">&quot;My LiteFX App&quot;</span>sv; }</div>
<div class="line">    <a class="code hl_typedef" href="namespace_lite_f_x.html#a8f67ef1b66d8e11201ba89c9db51c0c8">StringView</a> <a class="code hl_function" href="class_lite_f_x_1_1_app.html#a1997f2094b37bdcf8811af12af4395be">name</a>() const noexcept<span class="keyword"> override </span>{ <span class="keywordflow">return</span> Name(); }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <a class="code hl_class" href="class_lite_f_x_1_1_app_version.html">AppVersion</a> Version() { <span class="keywordflow">return</span> <a class="code hl_class" href="class_lite_f_x_1_1_app_version.html">AppVersion</a>(1, 0, 0, 0); }</div>
<div class="line">    <a class="code hl_class" href="class_lite_f_x_1_1_app_version.html">AppVersion</a> <a class="code hl_function" href="class_lite_f_x_1_1_app.html#a4ab4d210ed5fb4aae9a8f01d419fafd4">version</a>() const noexcept<span class="keyword"> override </span>{ <span class="keywordflow">return</span> Version(); }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    GLFWwindow m_window;</div>
<div class="line">    <a class="code hl_typedef" href="namespace_lite_f_x.html#a4d476c79a5aeb6ebe0f9d35bbc408d63">Optional&lt;UInt32&gt;</a> m_adapterId;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    MyApp(GLFWwindow window, <a class="code hl_typedef" href="namespace_lite_f_x.html#a4d476c79a5aeb6ebe0f9d35bbc408d63">Optional&lt;UInt32&gt;</a> adapterId) :</div>
<div class="line">    <a class="code hl_class" href="class_lite_f_x_1_1_app.html">App</a>(), m_window(window), m_adapterId(adapterId)</div>
<div class="line">    {</div>
<div class="line">    this-&gt;initializing += std::bind(&amp;MyApp::onInit, <span class="keyword">this</span>);</div>
<div class="line">    this-&gt;startup += std::bind(&amp;MyApp::onStartup, <span class="keyword">this</span>);</div>
<div class="line">    this-&gt;shutdown += std::bind(&amp;MyApp::onShutdown, <span class="keyword">this</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">void</span> onInit();</div>
<div class="line">    <span class="keywordtype">void</span> onStartup();</div>
<div class="line">    <span class="keywordtype">void</span> onShutdown();</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MyApp::onStartup()</div>
<div class="line">{</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MyApp::onShutdown()</div>
<div class="line">{</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MyApp::onInit()</div>
<div class="line">{</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keyword">const</span> <span class="keywordtype">int</span> argc, <span class="keyword">const</span> <span class="keywordtype">char</span>* argv[])</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
<div class="ttc" id="aclass_lite_f_x_1_1_app_html"><div class="ttname"><a href="class_lite_f_x_1_1_app.html">LiteFX::App</a></div><div class="ttdoc">The base class for an application.</div><div class="ttdef"><b>Definition</b> app.hpp:402</div></div>
<div class="ttc" id="aclass_lite_f_x_1_1_app_html_a1997f2094b37bdcf8811af12af4395be"><div class="ttname"><a href="class_lite_f_x_1_1_app.html#a1997f2094b37bdcf8811af12af4395be">LiteFX::App::name</a></div><div class="ttdeci">virtual StringView name() const noexcept=0</div><div class="ttdoc">Returns the name of the app.</div></div>
<div class="ttc" id="aclass_lite_f_x_1_1_app_html_a4ab4d210ed5fb4aae9a8f01d419fafd4"><div class="ttname"><a href="class_lite_f_x_1_1_app.html#a4ab4d210ed5fb4aae9a8f01d419fafd4">LiteFX::App::version</a></div><div class="ttdeci">virtual AppVersion version() const noexcept=0</div><div class="ttdoc">Returns the version of the app.</div></div>
<div class="ttc" id="aclass_lite_f_x_1_1_app_version_html"><div class="ttname"><a href="class_lite_f_x_1_1_app_version.html">LiteFX::AppVersion</a></div><div class="ttdoc">Contains the version of an App.</div><div class="ttdef"><b>Definition</b> app_api.hpp:50</div></div>
<div class="ttc" id="anamespace_lite_f_x_html_a4d476c79a5aeb6ebe0f9d35bbc408d63"><div class="ttname"><a href="namespace_lite_f_x.html#a4d476c79a5aeb6ebe0f9d35bbc408d63">LiteFX::Optional</a></div><div class="ttdeci">std::optional&lt; T &gt; Optional</div><div class="ttdoc">Represents an optional value.</div><div class="ttdef"><b>Definition</b> containers.hpp:94</div></div>
<div class="ttc" id="anamespace_lite_f_x_html_a8f67ef1b66d8e11201ba89c9db51c0c8"><div class="ttname"><a href="namespace_lite_f_x.html#a8f67ef1b66d8e11201ba89c9db51c0c8">LiteFX::StringView</a></div><div class="ttdeci">std::string_view StringView</div><div class="ttdef"><b>Definition</b> string.hpp:26</div></div>
</div><!-- fragment --><p>Here we define a very basic application object <code>MyApp</code>, that returns a name and a version. Furthermore, we already add event listeners to a few events that we are going to implement further down the line. The next step we need to do is to start creating an application window. For this we are going to use <em>glfw</em> in this tutorial.</p>
<h2><a class="anchor" id="autotoc_md15"></a>
Setting up the Application Window</h2>
<p>In this tutorial, we create the application window within the <code>main</code> function of the application. For this, we first store the application name, as we are going to need it again further later. We start by initializing <em>glfw</em>, telling it which kind of window we prefer and finally creating a window instance.</p>
<div class="fragment"><div class="line"><span class="comment">// main.cpp</span></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keyword">const</span> <span class="keywordtype">int</span> argc, <span class="keyword">const</span> <span class="keywordtype">char</span>* argv[])</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Store the app name.</span></div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_typedef" href="namespace_lite_f_x.html#a85a10b8c5c41d6c566c33bf05cf5aa51">String</a> appName{ MyApp::Name() };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create glfw window.</span></div>
<div class="line">    <span class="keywordflow">if</span> (!::glfwInit())</div>
<div class="line">    <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Unable to initialize glfw.&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    ::glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);</div>
<div class="line">    ::glfwWindowHint(GLFW_RESIZABLE, GLFW_TRUE);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> window = GlfwWindowPtr(::glfwCreateWindow(800, 600, appName.c_str(), <span class="keyword">nullptr</span>, <span class="keyword">nullptr</span>));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">}</div>
<div class="ttc" id="anamespace_lite_f_x_html_a85a10b8c5c41d6c566c33bf05cf5aa51"><div class="ttname"><a href="namespace_lite_f_x.html#a85a10b8c5c41d6c566c33bf05cf5aa51">LiteFX::String</a></div><div class="ttdeci">std::string String</div><div class="ttdef"><b>Definition</b> string.hpp:24</div></div>
</div><!-- fragment --><p>If we intent to use the Vulkan backend, glfw may require some extensions to be loaded. We can pass additional extensions to the backend at creation time later. But first, we need to check, if the Vulkan backend is provided. We can do this by evaluating the <code>LITEFX_BUILD_VULKAN_BACKEND</code> macro. This macro is only provided, if <a class="el" href="namespace_lite_f_x.html">LiteFX</a> is built with support for the Vulkan backend. You can omit the following code, if you are not intending on using Vulkan, but it is recommended to keep it in anyway to keep you application portable.</p>
<div class="fragment"><div class="line"><span class="comment">// main.cpp</span></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keyword">const</span> <span class="keywordtype">int</span> argc, <span class="keyword">const</span> <span class="keywordtype">char</span>* argv[])</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line"><span class="preprocessor">#ifdef LITEFX_BUILD_VULKAN_BACKEND</span></div>
<div class="line">    uint32_t extensions = 0;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>** extensionNames = ::glfwGetRequiredInstanceExtensions(&amp;extensions);</div>
<div class="line">    <a class="code hl_typedef" href="namespace_lite_f_x.html#a42542540c485a16fd8e34e9c173ac3f5">Array&lt;String&gt;</a> requiredExtensions;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (uint32_t i(0); i &lt; extensions; ++i)</div>
<div class="line">    requiredExtensions.emplace_back(extensionNames[i]);</div>
<div class="line"><span class="preprocessor">#endif </span><span class="comment">// LITEFX_BUILD_VULKAN_BACKEND</span></div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">}</div>
<div class="ttc" id="anamespace_lite_f_x_html_a42542540c485a16fd8e34e9c173ac3f5"><div class="ttname"><a href="namespace_lite_f_x.html#a42542540c485a16fd8e34e9c173ac3f5">LiteFX::Array</a></div><div class="ttdeci">std::vector&lt; T &gt; Array</div><div class="ttdoc">Represents a dynamic array.</div><div class="ttdef"><b>Definition</b> containers.hpp:73</div></div>
</div><!-- fragment --><p>Here we request the names of the extensions, required by glfw and add them to an array called <code>requiredExtensions</code>. We later pass this array to the Vulkan backend.</p>
<h2><a class="anchor" id="autotoc_md16"></a>
Running the Application</h2>
<p>Next we setup and run our application. For this, we use the builder interface to provide the backends we want to use. We wrap everything in a <code>try</code>/<code>catch</code> block, which is the last exception handler that catches everything we did not handle earlier. We tell the application to use the backends, that are available in the current build. We do this by wrapping the <code>useBackend</code> calls with the same macro(s) we used earlier for acquiring the required Vulkan extensions. We also enable logging to both, the console, as well as a <em>sample.log</em> file.</p>
<div class="fragment"><div class="line"><span class="comment">// main.cpp</span></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keyword">const</span> <span class="keywordtype">int</span> argc, <span class="keyword">const</span> <span class="keywordtype">char</span>* argv[])</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">    <span class="keywordflow">try</span></div>
<div class="line">    {</div>
<div class="line">    <a class="code hl_typedef" href="namespace_lite_f_x.html#a6daa7ddc3f560528522ba2849e09e3d3">UniquePtr&lt;App&gt;</a> app = App::build&lt;MyApp&gt;(window, std::nullopt)</div>
<div class="line">        .logTo&lt;<a class="code hl_class" href="class_lite_f_x_1_1_logging_1_1_console_sink.html">ConsoleSink</a>&gt;(LogLevel::Trace)</div>
<div class="line">        .logTo&lt;RollingFileSink&gt;(<span class="stringliteral">&quot;sample.log&quot;</span>, LogLevel::Debug)</div>
<div class="line"><span class="preprocessor">#ifdef LITEFX_BUILD_VULKAN_BACKEND</span></div>
<div class="line">        .useBackend&lt;<a class="code hl_class" href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_vulkan_backend.html">VulkanBackend</a>&gt;(requiredExtensions)</div>
<div class="line">#endif <span class="comment">// LITEFX_BUILD_VULKAN_BACKEND</span></div>
<div class="line">#ifdef LITEFX_BUILD_DIRECTX_12_BACKEND</div>
<div class="line">        .useBackend&lt;DirectX12Backend&gt;()</div>
<div class="line"><span class="preprocessor">#endif </span><span class="comment">// LITEFX_BUILD_DIRECTX_12_BACKEND</span></div>
<div class="line">        ;</div>
<div class="line"> </div>
<div class="line">    app-&gt;run();</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code hl_class" href="class_lite_f_x_1_1_exception.html">LiteFX::Exception</a>&amp; ex)</div>
<div class="line">    {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Unhandled exception: &quot;</span> &lt;&lt; ex.what() &lt;&lt; <span class="charliteral">&#39;\n&#39;</span> &lt;&lt; <span class="stringliteral">&quot;at: &quot;</span> &lt;&lt; ex.<a class="code hl_function" href="class_lite_f_x_1_1_exception.html#a7a71f4585eb9695901d874f4248fdf34">trace</a>() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">}</div>
<div class="ttc" id="aclass_lite_f_x_1_1_exception_html"><div class="ttname"><a href="class_lite_f_x_1_1_exception.html">LiteFX::Exception</a></div><div class="ttdoc">The base class for exceptions thrown by the SDK.</div><div class="ttdef"><b>Definition</b> exceptions.hpp:16</div></div>
<div class="ttc" id="aclass_lite_f_x_1_1_exception_html_a7a71f4585eb9695901d874f4248fdf34"><div class="ttname"><a href="class_lite_f_x_1_1_exception.html#a7a71f4585eb9695901d874f4248fdf34">LiteFX::Exception::trace</a></div><div class="ttdeci">const std::stacktrace &amp; trace() const noexcept</div><div class="ttdoc">Gets the stack trace leading to the exception.</div><div class="ttdef"><b>Definition</b> exceptions.hpp:52</div></div>
<div class="ttc" id="aclass_lite_f_x_1_1_logging_1_1_console_sink_html"><div class="ttname"><a href="class_lite_f_x_1_1_logging_1_1_console_sink.html">LiteFX::Logging::ConsoleSink</a></div><div class="ttdoc">Writes log messages to the console.</div><div class="ttdef"><b>Definition</b> logging.hpp:77</div></div>
<div class="ttc" id="aclass_lite_f_x_1_1_rendering_1_1_backends_1_1_vulkan_backend_html"><div class="ttname"><a href="class_lite_f_x_1_1_rendering_1_1_backends_1_1_vulkan_backend.html">LiteFX::Rendering::Backends::VulkanBackend</a></div><div class="ttdoc">Defines a rendering backend that creates a Vulkan device.</div><div class="ttdef"><b>Definition</b> vulkan.hpp:2752</div></div>
<div class="ttc" id="anamespace_lite_f_x_html_a6daa7ddc3f560528522ba2849e09e3d3"><div class="ttname"><a href="namespace_lite_f_x.html#a6daa7ddc3f560528522ba2849e09e3d3">LiteFX::UniquePtr</a></div><div class="ttdeci">std::unique_ptr&lt; T, TDeleter &gt; UniquePtr</div><div class="ttdoc">Represents a unique pointer, that expresses exclusive ownership.</div><div class="ttdef"><b>Definition</b> containers.hpp:102</div></div>
</div><!-- fragment --><p>As you can see, we pass the window pointer as well as another parameter <code>std::nullopt</code> to the application constructor. This second parameter is an optional index to a physical adapter. We can force execution on a certain driver here explicitly, however when providing with the default option, the first one returned from the graphics API is used. Depending on the system, this is the one you've selected as the default GPU to use in your system settings.</p>
<h1><a class="anchor" id="autotoc_md17"></a>
Initializing the Engine</h1>
<p>Currently, if we start the application, a window will open for a short time and immediately close again. This is expected, as we do not have defined any logic just yet. In <a class="el" href="namespace_lite_f_x.html">LiteFX</a>, an <code>App</code> goes through a series of stages, namely <em>initialization</em>, <em>startup</em> and <em>shutdown</em>. Each of those stages invokes event handlers where the actual logic is implemented. We already defined the events and bound event handlers to them. All we have to do is implementing those event handlers in their corresponding methods. We start by implementing the <code>onInit</code> method, that we bound to the <code>initializing</code> event in the <code>MyApp</code> constructor. In this method, we setup everything that's required for the application to run. Besides custom logic, this mainly involves providing start and stop handlers for the backends. Just as the app instance has separate stages it goes through in its lifetime, backends invoke event handlers whenever they are started or stopped. We need to the proper logic for the those handlers. For this, we use a template lambda, that receives a pointer to the backend for which the handler is invoked.</p>
<div class="fragment"><div class="line"><span class="comment">// main.cpp</span></div>
<div class="line"><span class="keywordtype">void</span> MyApp::onInit()</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">auto</span> startCallback = [<span class="keyword">this</span>]&lt;<span class="keyword">typename</span> TBackend&gt;(TBackend* backend) {</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> stopCallback = []&lt;<span class="keyword">typename</span> TBackend&gt;(TBackend* backend) {</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef LITEFX_BUILD_VULKAN_BACKEND</span></div>
<div class="line">    this-&gt;onBackendStart&lt;VulkanBackend&gt;(startCallback);</div>
<div class="line">    this-&gt;onBackendStop&lt;VulkanBackend&gt;(stopCallback);</div>
<div class="line"><span class="preprocessor">#endif </span><span class="comment">// LITEFX_BUILD_VULKAN_BACKEND</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef LITEFX_BUILD_DIRECTX_12_BACKEND</span></div>
<div class="line">    this-&gt;onBackendStart&lt;DirectX12Backend&gt;(startCallback);</div>
<div class="line">    this-&gt;onBackendStop&lt;DirectX12Backend&gt;(stopCallback);</div>
<div class="line"><span class="preprocessor">#endif </span><span class="comment">// LITEFX_BUILD_DIRECTX_12_BACKEND</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>Note that there can only be one backend of a certain type be active at a time, the app instance makes sure to call the handlers in the appropriate order. Also note that the first backend we register with an application of each type is automatically started after initialization. Starting a backend involves calling the first handler we are going to implement. In this start handler, we first acquire the current framebuffer size from the glfw window instance, which we use to initialize the drawing region with. We also define a viewport and scissor rectangle over the whole area of the drawing region and store them in a member variable, as we need to access them again later. Finally, we lookup the adapter from the adapter id we provided earlier, create a surface instance and finally create a device, of which we store a pointer. This device is the key object required to allocate any further rendering resources from.</p>
<div class="fragment"><div class="line"><span class="comment">// main.cpp</span></div>
<div class="line"><span class="keyword">class </span>MyApp : <span class="keyword">public</span> <a class="code hl_class" href="class_lite_f_x_1_1_app.html">LiteFX::App</a> {</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    GLFWwindow m_window;</div>
<div class="line">    <a class="code hl_typedef" href="namespace_lite_f_x.html#a4d476c79a5aeb6ebe0f9d35bbc408d63">Optional&lt;UInt32&gt;</a> m_adapterId;</div>
<div class="line">    <a class="code hl_typedef" href="namespace_lite_f_x.html#a58ddcdf7464eb219bb14d225153daa7f">SharedPtr&lt;Viewport&gt;</a> m_viewport;</div>
<div class="line">    <a class="code hl_typedef" href="namespace_lite_f_x.html#a58ddcdf7464eb219bb14d225153daa7f">SharedPtr&lt;Scissor&gt;</a> m_scissor;</div>
<div class="line">    <a class="code hl_class" href="class_lite_f_x_1_1_rendering_1_1_i_graphics_device.html">IGraphicsDevice</a>* m_device;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MyApp::onInit()</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">auto</span> startCallback = [<span class="keyword">this</span>]&lt;<span class="keyword">typename</span> TBackend&gt;(TBackend* backend) {</div>
<div class="line">    <span class="comment">// Get the frame buffer size.</span></div>
<div class="line">    <span class="keywordtype">int</span> width{}, height{};</div>
<div class="line">    ::glfwGetFramebufferSize(m_window, &amp;width, &amp;height);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create viewport and scissors.</span></div>
<div class="line">    m_viewport = makeShared&lt;Viewport&gt;(<a class="code hl_class" href="class_lite_f_x_1_1_math_1_1_rect_f.html">RectF</a>(0.f, 0.f, <span class="keyword">static_cast&lt;</span><a class="code hl_typedef" href="namespace_lite_f_x_1_1_math.html#a7272a8e096481053b319d7658c1c5484">Float</a><span class="keyword">&gt;</span>(width), <span class="keyword">static_cast&lt;</span><a class="code hl_typedef" href="namespace_lite_f_x_1_1_math.html#a7272a8e096481053b319d7658c1c5484">Float</a><span class="keyword">&gt;</span>(height)));</div>
<div class="line">    m_scissor = makeShared&lt;Scissor&gt;(<a class="code hl_class" href="class_lite_f_x_1_1_math_1_1_rect_f.html">RectF</a>(0.f, 0.f, <span class="keyword">static_cast&lt;</span><a class="code hl_typedef" href="namespace_lite_f_x_1_1_math.html#a7272a8e096481053b319d7658c1c5484">Float</a><span class="keyword">&gt;</span>(width), <span class="keyword">static_cast&lt;</span><a class="code hl_typedef" href="namespace_lite_f_x_1_1_math.html#a7272a8e096481053b319d7658c1c5484">Float</a><span class="keyword">&gt;</span>(height)));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Find the adapter, create a surface and initialize the device.</span></div>
<div class="line">    <span class="keyword">auto</span> adapter = backend-&gt;findAdapter(m_adapterId);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (adapter == <span class="keyword">nullptr</span>)</div>
<div class="line">        adapter = backend-&gt;findAdapter(std::nullopt);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> surface = backend-&gt;createSurface(::glfwGetWin32Window(window));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create the device.</span></div>
<div class="line">    <span class="keyword">auto</span> device = std::addressof(backend-&gt;createDevice(<span class="stringliteral">&quot;Default&quot;</span>, *adapter, std::move(surface), Format::B8G8R8A8_UNORM, m_viewport-&gt;getRectangle().extent(), 3, <span class="keyword">false</span>));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Store the device and return,</span></div>
<div class="line">    m_device = device;</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">}</div>
<div class="ttc" id="aclass_lite_f_x_1_1_math_1_1_rect_f_html"><div class="ttname"><a href="class_lite_f_x_1_1_math_1_1_rect_f.html">LiteFX::Math::RectF</a></div><div class="ttdef"><b>Definition</b> math.hpp:926</div></div>
<div class="ttc" id="aclass_lite_f_x_1_1_rendering_1_1_i_graphics_device_html"><div class="ttname"><a href="class_lite_f_x_1_1_rendering_1_1_i_graphics_device.html">LiteFX::Rendering::IGraphicsDevice</a></div><div class="ttdoc">The interface for a graphics device that.</div><div class="ttdef"><b>Definition</b> rendering_api.hpp:9164</div></div>
<div class="ttc" id="anamespace_lite_f_x_1_1_math_html_a7272a8e096481053b319d7658c1c5484"><div class="ttname"><a href="namespace_lite_f_x_1_1_math.html#a7272a8e096481053b319d7658c1c5484">LiteFX::Math::Float</a></div><div class="ttdeci">float_t Float</div><div class="ttdoc">A type for a floating point value with single precision.</div><div class="ttdef"><b>Definition</b> math.hpp:71</div></div>
<div class="ttc" id="anamespace_lite_f_x_html_a58ddcdf7464eb219bb14d225153daa7f"><div class="ttname"><a href="namespace_lite_f_x.html#a58ddcdf7464eb219bb14d225153daa7f">LiteFX::SharedPtr</a></div><div class="ttdeci">std::shared_ptr&lt; T &gt; SharedPtr</div><div class="ttdoc">Represents a shared pointer, that expresses non-exclusive ownership.</div><div class="ttdef"><b>Definition</b> containers.hpp:109</div></div>
</div><!-- fragment --><p>Note how we only store a pointer to the device instance. We do this, as the lifetime of the device is managed by the backend. In order to release the device when we shutdown the backend, we need to provide a stop handler. This looks similar to the start handler, but has much less logic to it, as all we need to do is to instruct the backend to release our device.</p>
<div class="fragment"><div class="line"><span class="comment">// main.cpp</span></div>
<div class="line"><span class="keywordtype">void</span> MyApp::onInit()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> stopCallback = []&lt;<span class="keyword">typename</span> TBackend&gt;(TBackend* backend) {</div>
<div class="line">    backend-&gt;releaseDevice(<span class="stringliteral">&quot;Default&quot;</span>);</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md18"></a>
Application Start and Stop</h1>
<p>The next step is to implement the main application loop. After the application has been successfully initialized, the startup handler is called. Here, we have to provide the main application loop. As we are using glfw in this example, we can use it to query for any exit events. As long as we did not hit any, all we have to do is to poll the next events from the message pump. Later, we are also going to insert the actual frame drawing logic here, but for now, let's keep it this way to ensure the application remains running until we say otherwise.</p>
<div class="fragment"><div class="line"><span class="comment">// main.cpp</span></div>
<div class="line"><span class="keywordtype">void</span> SampleApp::onStartup()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">while</span> (!::glfwWindowShouldClose(m_window))</div>
<div class="line">    {</div>
<div class="line">    ::glfwPollEvents();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>After leaving the startup handler, the application calls the shutdown handler. In this handler, we tell glfw to destroy our window and terminate the application. Note that the stop handlers for all active backends are called before this handler executes.</p>
<div class="fragment"><div class="line"><span class="comment">// main.cpp</span></div>
<div class="line"><span class="keywordtype">void</span> SampleApp::onShutdown()</div>
<div class="line">{</div>
<div class="line">    ::glfwDestroyWindow(m_window);</div>
<div class="line">    ::glfwTerminate();</div>
<div class="line">}</div>
</div><!-- fragment --><p>Now if we run our application, the window should remain open, but still we did not draw anything into it. Let's change this by drawing a your first triangle!</p>
<h1><a class="anchor" id="autotoc_md19"></a>
Preparation</h1>
<p>Every rendering engine requires different resources to be setup before drawing anything to the window. First, we need tell the engine <em>what</em> to draw by providing a vertex and an index buffer. Next, we need to tell the GPU <em>how</em> to draw our triangle by providing a pipeline state. On top of this, we need to define the <em>where</em> (frame buffer) and <em>when</em> (render pass) context for the render process. We will take care of the other resources in a bit, but first let's start by defining a data structure for our vertices and providing enough memory for our triangle vertex and index buffers.</p>
<div class="fragment"><div class="line"><span class="comment">// main.cpp</span></div>
<div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="struct_vertex.html">Vertex</a> {</div>
<div class="line">    <a class="code hl_class" href="class_lite_f_x_1_1_math_1_1_vector4f.html">Vector4f</a> position;</div>
<div class="line">    <a class="code hl_class" href="class_lite_f_x_1_1_math_1_1_vector4f.html">Vector4f</a> color;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MyApp : <span class="keyword">public</span> <a class="code hl_class" href="class_lite_f_x_1_1_app.html">LiteFX::App</a> {</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    GLFWwindow m_window;</div>
<div class="line">    <a class="code hl_typedef" href="namespace_lite_f_x.html#a4d476c79a5aeb6ebe0f9d35bbc408d63">Optional&lt;UInt32&gt;</a> m_adapterId;</div>
<div class="line">    <a class="code hl_typedef" href="namespace_lite_f_x.html#a58ddcdf7464eb219bb14d225153daa7f">SharedPtr&lt;Viewport&gt;</a> m_viewport;</div>
<div class="line">    <a class="code hl_typedef" href="namespace_lite_f_x.html#a58ddcdf7464eb219bb14d225153daa7f">SharedPtr&lt;Scissor&gt;</a> m_scissor;</div>
<div class="line">    <a class="code hl_class" href="class_lite_f_x_1_1_rendering_1_1_i_graphics_device.html">IGraphicsDevice</a>* m_device;</div>
<div class="line"> </div>
<div class="line">    std::array&lt;Vertex, 3&gt; m_vertices {</div>
<div class="line">    <a class="code hl_struct" href="struct_vertex.html">Vertex</a> { { 0.1, 0.1, 1.0, 1.0 }, { 1.0, 0.0, 0.0, 1.0 } },</div>
<div class="line">    <a class="code hl_struct" href="struct_vertex.html">Vertex</a> { { 0.9, 0.1, 1.0, 1.0 }, { 0.0, 1.0, 0.0, 1.0 } },</div>
<div class="line">    <a class="code hl_struct" href="struct_vertex.html">Vertex</a> { { 0.5, 0.9, 1.0, 1.0 }, { 0.0, 0.0, 1.0, 1.0 } }</div>
<div class="line">    };</div>
<div class="line">    std::array&lt;UInt16, 3&gt; m_indices { 0, 1, 2 };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">};</div>
<div class="ttc" id="aclass_lite_f_x_1_1_math_1_1_vector4f_html"><div class="ttname"><a href="class_lite_f_x_1_1_math_1_1_vector4f.html">LiteFX::Math::Vector4f</a></div><div class="ttdef"><b>Definition</b> math.hpp:534</div></div>
<div class="ttc" id="astruct_vertex_html"><div class="ttname"><a href="struct_vertex.html">Vertex</a></div><div class="ttdef"><b>Definition</b> alloc_descriptor_set.cpp:13</div></div>
</div><!-- fragment --><p>Currently our data only lives on the CPU and in order to draw the triangle, we need to transfer it to the GPU first. However, before we can do this, we need to setup the rest of the renderer first. We start by defining the frame buffer and render pass.</p>
<h2><a class="anchor" id="autotoc_md20"></a>
Frame Buffer and Render Pass</h2>
<p>In graphics, the frame buffer is a concept that refers to a set of images that the GPU can draw into. Such images are called <em>render targets</em> and a frame buffer can have multiple of them. Different to other engines, the frame buffer in <a class="el" href="namespace_lite_f_x.html">LiteFX</a> is a shared container for all available render targets, including those for multiple "frames in flight" (i.e., frames that are potentially already rendered, before an earlier frame is even displayed). Render targets can have different formats, depending on the information they store. On top of this, a render target has a type that describes for what it is used for. Depending on this type, only a set of formats is valid. <a class="el" href="namespace_lite_f_x.html">LiteFX</a> provides the following types of render targets:</p>
<ul>
<li><b>Color</b>: a common image that stores "color" information. However this color may encode different things besides actual color, for example normals or material properties.</li>
<li><b>Depth/Stencil</b>: a buffer that can have a depth component, a stencil component or both. This buffer is special, as it can be used to selectively discard pixels during rendering, depending on its values.</li>
<li><b>Present</b>: similar to a color target, but special in a sense that there can only be one present target in a render pass chain. Ending a render pass that contains a present target will submit a present call, so that the contents of this render target will be displayed to the user.</li>
</ul>
<p>In our simple example we only need to define a present target, as all we want to do is draw the pixels of the triangle onto the screen. We start by defining a render pass that only writes into this render target.</p>
<blockquote class="doxtable">
<p>&zwj;For more involved examples on how to use frame buffers, check out the <a href="https://github.com/crud89/LiteFX/tree/tutorial-rewrite/src/Samples">engine samples</a>, especially the <a href="https://github.com/crud89/LiteFX/tree/tutorial-rewrite/src/Samples/RenderPasses">render pass sample</a>. </p>
</blockquote>
<div class="fragment"><div class="line"><span class="comment">// main.cpp</span></div>
<div class="line"><span class="keyword">auto</span> startCallback = [<span class="keyword">this</span>]&lt;<span class="keyword">typename</span> TBackend&gt;(TBackend* backend) {</div>
<div class="line">    <span class="comment">// Alias type names for improved readability.</span></div>
<div class="line">    <span class="keyword">using </span><a class="code hl_class" href="class_lite_f_x_1_1_rendering_1_1_render_pass.html">RenderPass</a> = TBackend::render_pass_type;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create the device.</span></div>
<div class="line">    <span class="keyword">auto</span> device = std::addressof(backend-&gt;createDevice(<span class="stringliteral">&quot;Default&quot;</span>, *adapter, std::move(surface), Format::B8G8R8A8_UNORM, m_viewport-&gt;getRectangle().extent(), 3, <span class="keyword">false</span>));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create a render pass.</span></div>
<div class="line">    <a class="code hl_typedef" href="namespace_lite_f_x.html#a58ddcdf7464eb219bb14d225153daa7f">SharedPtr&lt;RenderPass&gt;</a> renderPass = device-&gt;buildRenderPass(<span class="stringliteral">&quot;Geometry&quot;</span>)</div>
<div class="line">    .renderTarget(<span class="stringliteral">&quot;Color Target&quot;</span>, RenderTargetType::Present, Format::B8G8R8A8_UNORM, RenderTargetFlags::Clear, { 0.1f, 0.1f, 0.1f, 1.f });</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Store the device and return,</span></div>
<div class="line">    m_device = device;</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">};</div>
<div class="ttc" id="aclass_lite_f_x_1_1_rendering_1_1_render_pass_html"><div class="ttname"><a href="class_lite_f_x_1_1_rendering_1_1_render_pass.html">LiteFX::Rendering::RenderPass</a></div><div class="ttdoc">Represents a render pass.</div><div class="ttdef"><b>Definition</b> rendering.hpp:1150</div></div>
</div><!-- fragment --><p>Here we define a render pass called "Geometry" with one present render target called "Color Target". Note that the color format is chosen deliberately, as present targets only support a few selected formats, depending on the display. The B8G8R8A8_UNORM is the default format for non HDR images and is always available. The last two settings define how that render target should be cleared. Clearing refers to the overdrawing of all pixels in the render target image with a constant color when starting the render pass. The very last parameter for the render target is the clear color, which in our case is a very dark gray (with an opaque alpha value).</p>
<p>The render pass itself does not allocate the images that are drawn to. A render target merely describes how the render pass handles the image passed to it for this matter. The images themselves are stored by a frame buffer, which is the next resource we are going to create.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> startCallback = [<span class="keyword">this</span>]&lt;<span class="keyword">typename</span> TBackend&gt;(TBackend* backend) {</div>
<div class="line">    <span class="comment">// Alias type names for improved readability.</span></div>
<div class="line">    <span class="keyword">using </span><a class="code hl_class" href="class_lite_f_x_1_1_rendering_1_1_render_pass.html">RenderPass</a> = TBackend::render_pass_type;</div>
<div class="line">    <span class="keyword">using </span><a class="code hl_class" href="class_lite_f_x_1_1_rendering_1_1_frame_buffer.html">FrameBuffer</a> = TBackend::frame_buffer_type;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create a render pass.</span></div>
<div class="line">    <a class="code hl_typedef" href="namespace_lite_f_x.html#a58ddcdf7464eb219bb14d225153daa7f">SharedPtr&lt;RenderPass&gt;</a> renderPass = device-&gt;buildRenderPass(<span class="stringliteral">&quot;Geometry&quot;</span>)</div>
<div class="line">    .renderTarget(<span class="stringliteral">&quot;Color Target&quot;</span>, RenderTargetType::Present, Format::B8G8R8A8_UNORM, RenderTargetFlags::Clear, { 0.1f, 0.1f, 0.1f, 1.f });</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Create the frame buffer.</span></div>
<div class="line">    <span class="keyword">auto</span> frameBuffers = std::views::iota(0u, device-&gt;swapChain().buffers()) |</div>
<div class="line">    std::views::transform([&amp;](<a class="code hl_typedef" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a> index) { <span class="keywordflow">return</span> device-&gt;makeFrameBuffer(std::format(<span class="stringliteral">&quot;Frame Buffer {0}&quot;</span>, index), device-&gt;swapChain().renderArea()); }) |</div>
<div class="line">    std::ranges::to&lt;<a class="code hl_typedef" href="namespace_lite_f_x.html#a42542540c485a16fd8e34e9c173ac3f5">Array</a>&lt;<a class="code hl_typedef" href="namespace_lite_f_x.html#a58ddcdf7464eb219bb14d225153daa7f">SharedPtr&lt;FrameBuffer&gt;</a>&gt;&gt;();</div>
<div class="line"> </div>
<div class="line">    std::ranges::for_each(frameBuffers, [&amp;renderPass](<span class="keyword">auto</span>&amp; frameBuffer) { frameBuffer-&gt;addImages(renderPass-&gt;renderTargets()); });</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Store the device and return,</span></div>
<div class="line">    m_device = device;</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">};</div>
<div class="ttc" id="aclass_lite_f_x_1_1_rendering_1_1_frame_buffer_html"><div class="ttname"><a href="class_lite_f_x_1_1_rendering_1_1_frame_buffer.html">LiteFX::Rendering::FrameBuffer</a></div><div class="ttdoc">Stores the images used by a RenderPass to either read from using input attachments or write to using ...</div><div class="ttdef"><b>Definition</b> rendering.hpp:1057</div></div>
<div class="ttc" id="anamespace_lite_f_x_1_1_math_html_a9d0c69f488431cf242a743f5bee8065f"><div class="ttname"><a href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">LiteFX::Math::UInt32</a></div><div class="ttdeci">uint32_t UInt32</div><div class="ttdoc">A type for an unsigned 32 bit integer.</div><div class="ttdef"><b>Definition</b> math.hpp:56</div></div>
</div><!-- fragment --><p>Here we first create a frame buffer for each frame in the swap chain. The frame buffer itself stores a render area, which we directly pass from the swap chain. It uses this as a default size for images it allocated. After creating the frame buffer, we can call <code>addImages</code> on it to create an image for a series of render targets. In our case, we pass the render target of the render pass we created earlier.</p>
<h2><a class="anchor" id="autotoc_md21"></a>
The Shader Program</h2>
<p>Now let's begin describing the <em>how</em> part of the render pipeline. We start of by creating our first shader program. A shader program is basically a program that runs on the GPU in order to draw our geometry. This for the most part works very different to any program we write on the CPU. For our simple triangle we only take a look at one type of shader program - the graphics program. The graphics pipeline is the oldest pipeline available to GPUs. Historically, it wasn't even programmable but entirely <em>fixed-function</em>, meaning that the individual stages could only be influenced by different parameters. Nowadays, we have programmable graphics pipelines, where individual <em>shader stages</em> can be programmed using <em>shader modules</em>, where each stage can have a module. There are, however, still some fixed-function stages. All the settings (beside the shader program) we are providing here to setup the rendering process are used to configure those stages. A shader program is built from the shader modules provided to it. A graphics program requires at least a vertex and a fragment shader (or pixel shader in DirectX terms) and not more than one shader module must be provided per shader stage.</p>
<p>In modern graphics APIs, shader modules are provided in pre-compiled shader byte-code. Each graphics backend uses their own format for this, but D3D12 will too support SPIR-V in the future, meaning we can re-use the same shaders for Vulkan and DirectX! However, as for now, we need to compile the shaders for each of those backends. <a class="el" href="namespace_lite_f_x.html">LiteFX</a> provides utilities for this in form of CMake macros. To start off, let's first create a new folder within the root directory of our project called <code>shaders</code>. Within this folder, create two text files <code>tutorial_vs.hlsl</code> (for the vertex shader) and <code>tutorial_fs.hlsl</code> (for the fragment shader). Note that we write our shaders in HLSL, as we can compile it into both byte-code variants, which is not trivially possible using GLSL.</p>
<p>To include the shaders into our project, open the CMakeLists.txt file and add the following lines:</p>
<div class="fragment"><div class="line"># CMakeLists.txt</div>
<div class="line"> </div>
<div class="line"># ...</div>
<div class="line"> </div>
<div class="line">ADD_EXECUTABLE(MyApp</div>
<div class="line">  &quot;main.h&quot;</div>
<div class="line">  &quot;main.cpp&quot;</div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line">TARGET_LINK_LIBRARIES(MyApp PRIVATE LiteFX.Backends.Vulkan LiteFX.Backends.DirectX12 glfw)</div>
<div class="line"> </div>
<div class="line">ADD_SHADER_MODULE(${PROJECT_NAME}.Vk.Shaders.VS SOURCE &quot;shaders/tutorial_vs.hlsl&quot; LANGUAGE HLSL TYPE VERTEX   COMPILE_AS SPIRV SHADER_MODEL 6_5 COMPILER DXC)</div>
<div class="line">ADD_SHADER_MODULE(${PROJECT_NAME}.Vk.Shaders.FS SOURCE &quot;shaders/tutorial_fs.hlsl&quot; LANGUAGE HLSL TYPE FRAGMENT COMPILE_AS SPIRV SHADER_MODEL 6_5 COMPILER DXC)</div>
<div class="line">ADD_SHADER_MODULE(${PROJECT_NAME}.Dx.Shaders.VS SOURCE &quot;shaders/tutorial_vs.hlsl&quot; LANGUAGE HLSL TYPE VERTEX   COMPILE_AS DXIL SHADER_MODEL 6_5 COMPILER DXC)</div>
<div class="line">ADD_SHADER_MODULE(${PROJECT_NAME}.Dx.Shaders.PS SOURCE &quot;shaders/tutorial_fs.hlsl&quot; LANGUAGE HLSL TYPE PIXEL    COMPILE_AS DXIL SHADER_MODEL 6_5 COMPILER DXC)</div>
<div class="line"> </div>
<div class="line">TARGET_LINK_SHADERS(${PROJECT_NAME} </div>
<div class="line">    INSTALL_DESTINATION &quot;${CMAKE_INSTALL_BINARY_DIR}/${SHADER_DEFAULT_SUBDIR}&quot;</div>
<div class="line">    SHADERS ${PROJECT_NAME}.Vk.Shaders.VS ${PROJECT_NAME}.Vk.Shaders.FS</div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line">TARGET_LINK_SHADERS(${PROJECT_NAME} </div>
<div class="line">    INSTALL_DESTINATION &quot;${CMAKE_INSTALL_BINARY_DIR}/${SHADER_DEFAULT_SUBDIR}&quot;</div>
<div class="line">    SHADERS ${PROJECT_NAME}.Dx.Shaders.VS ${PROJECT_NAME}.Dx.Shaders.PS</div>
<div class="line">)</div>
</div><!-- fragment --><p>Here, we first declare the shader modules individually, once targeting each byte-code backend. We then tell CMake to link them to our application. This results in the shaders being compiled and then copied over to the binary directory, from which we can load them during application runtime. Let's take a look at the individual shaders.</p>
<h3><a class="anchor" id="autotoc_md22"></a>
The Vertex Shader</h3>
<p>The first shader module we are looking at is the vertex shader. This shader is executed for each individual vertex in the vertex buffer. In this shader module, we first define the data structure of the input vertex data. Note how this is similar to the vertex structure we defined in our program earlier. However, you will also notice the <code>POSITION</code> and <code>COLOR</code> declarators behind the field names. Those are called <em>attribute semantics</em> and inform the GPU of what the data stored within the field refers to.</p>
<p>The second structure defines the output vertex data. In our simple example, each vertex simply outputs its color and position without any transformation. When the fragment shader module is executed later, the GPU interpolates between the values returned for each vertex of the triangle to compute an actual color value that will be passed to the fragment shader.</p>
<div class="fragment"><div class="line">// tutorial_vs.hlsl</div>
<div class="line">struct VertexInput</div>
<div class="line">{</div>
<div class="line">    float4 Position : POSITION;</div>
<div class="line">    float4 Color : COLOR;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">struct VertexData</div>
<div class="line">{</div>
<div class="line">    float4 Position : SV_POSITION;</div>
<div class="line">    float4 Color : COLOR;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">VertexData main(in VertexInput input)</div>
<div class="line">{</div>
<div class="line">    VertexData vertex;</div>
<div class="line">    </div>
<div class="line">    vertex.Position = input.Position;</div>
<div class="line">    vertex.Color = input.Color;</div>
<div class="line"> </div>
<div class="line">    return vertex;</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md23"></a>
The Fragment/Pixel Shader</h3>
<p>The second shader module in our pipeline is the fragment or pixel shader. This shader is executed for each fragment (which is slightly different from an actual pixel, but equivalent without MSAA). Despite defined identical to the output data above, the input data here contains interpolated per-fragment information, as a fragment may be located inside a triangle. The output data is also very simple, as we only return the interpolated fragment color here. The <code>SV_TARGET</code> semantic informs the GPU that the value should be stored in the (first) render target.</p>
<div class="fragment"><div class="line">// tutorial_fs.hlsl</div>
<div class="line">struct VertexData</div>
<div class="line">{</div>
<div class="line">    float4 Position : SV_POSITION;</div>
<div class="line">    float4 Color : COLOR;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">struct FragmentData</div>
<div class="line">{</div>
<div class="line">    float4 Color : SV_TARGET;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">FragmentData main(VertexData input)</div>
<div class="line">{</div>
<div class="line">    FragmentData fragment;</div>
<div class="line">    fragment.Color = input.Color;</div>
<div class="line">    return fragment;</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md24"></a>
Setting up the Shader Program</h3>
<p>When re-compiling the program, you should now notice how the shaders will be included in the build process. Also note how they are stored within the <code>shaders</code> subdirectory of the binary directory, where two versions of each shader exist, one with the <code>.dxi</code> extension that stores the DXIL byte-code and one with the <code>.spv</code> extension, that stores the SPIR-V byte-code. Back in our application we now need to load the proper shader for the backend. For this, we first check which backend we are currently starting and then store the extension accordingly. After this, we define a shader program using the names of the shader module files we just created.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> startCallback = [<span class="keyword">this</span>]&lt;<span class="keyword">typename</span> TBackend&gt;(TBackend* backend) {</div>
<div class="line">    <span class="comment">// Alias type names for improved readability.</span></div>
<div class="line">    <span class="keyword">using </span><a class="code hl_class" href="class_lite_f_x_1_1_rendering_1_1_render_pass.html">RenderPass</a> = TBackend::render_pass_type;</div>
<div class="line">    <span class="keyword">using </span><a class="code hl_class" href="class_lite_f_x_1_1_rendering_1_1_frame_buffer.html">FrameBuffer</a> = TBackend::frame_buffer_type;</div>
<div class="line">    <span class="keyword">using </span><a class="code hl_class" href="class_lite_f_x_1_1_rendering_1_1_shader_program.html">ShaderProgram</a> = TBackend::shader_program_type;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create a render pass.</span></div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Create the frame buffer.</span></div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Find the proper file extension.</span></div>
<div class="line">    <a class="code hl_typedef" href="namespace_lite_f_x.html#a85a10b8c5c41d6c566c33bf05cf5aa51">String</a> extension;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (std::is_same_v&lt;TBackend, VulkanBackend&gt;)</div>
<div class="line">        extension = <span class="stringliteral">&quot;spv&quot;</span>;</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (std::is_same_v&lt;TBackend, DirectX12Backend&gt;)</div>
<div class="line">        extension = <span class="stringliteral">&quot;dxi&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create the shader program.</span></div>
<div class="line">    <a class="code hl_typedef" href="namespace_lite_f_x.html#a58ddcdf7464eb219bb14d225153daa7f">SharedPtr&lt;ShaderProgram&gt;</a> shaderProgram = device-&gt;buildShaderProgram()</div>
<div class="line">        .withVertexShaderModule(std::format(<span class="stringliteral">&quot;shaders/tutorial_vs.{}&quot;</span>, extension))</div>
<div class="line">        .withFragmentShaderModule(std::format(<span class="stringliteral">&quot;shaders/tutorial_fs.{}&quot;</span>, extension));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Store the device and return,</span></div>
<div class="line">    m_device = device;</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">};</div>
<div class="ttc" id="aclass_lite_f_x_1_1_rendering_1_1_shader_program_html"><div class="ttname"><a href="class_lite_f_x_1_1_rendering_1_1_shader_program.html">LiteFX::Rendering::ShaderProgram</a></div><div class="ttdoc">Represents a shader program, consisting of multiple IShaderModules.</div><div class="ttdef"><b>Definition</b> rendering.hpp:386</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md25"></a>
Render Pipeline State</h2>
<p>Last on our list is the render pipeline state. This state tells the GPU how to render the geometry. For this, it needs a good amount of information. First, we need to define the input assembler state. The input assembler is part of the fixed-function pipeline and loads the data we provide to the GPU into the render pipeline. Using the input assembler state, we describe how this data is laid out and what the individual values represent.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> startCallback = [<span class="keyword">this</span>]&lt;<span class="keyword">typename</span> TBackend&gt;(TBackend* backend) {</div>
<div class="line">    <span class="comment">// Alias type names for improved readability.</span></div>
<div class="line">    <span class="keyword">using </span><a class="code hl_class" href="class_lite_f_x_1_1_rendering_1_1_render_pass.html">RenderPass</a> = TBackend::render_pass_type;</div>
<div class="line">    <span class="keyword">using </span><a class="code hl_class" href="class_lite_f_x_1_1_rendering_1_1_frame_buffer.html">FrameBuffer</a> = TBackend::frame_buffer_type;</div>
<div class="line">    <span class="keyword">using </span><a class="code hl_class" href="class_lite_f_x_1_1_rendering_1_1_shader_program.html">ShaderProgram</a> = TBackend::shader_program_type;</div>
<div class="line">    <span class="keyword">using </span><a class="code hl_class" href="class_lite_f_x_1_1_rendering_1_1_input_assembler.html">InputAssembler</a> = TBackend::input_assembler_type;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create a render pass.</span></div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Create the frame buffer.</span></div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Find the proper file extension.</span></div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create the shader program.</span></div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Create input assembler state.</span></div>
<div class="line">    <a class="code hl_typedef" href="namespace_lite_f_x.html#a58ddcdf7464eb219bb14d225153daa7f">SharedPtr&lt;InputAssembler&gt;</a> inputAssembler = device-&gt;buildInputAssembler()</div>
<div class="line">        .<a class="code hl_function" href="class_lite_f_x_1_1_rendering_1_1_i_input_assembler.html#a5e652f2d535bcaeacf4fd24d7738064f">topology</a>(PrimitiveTopology::TriangleList)</div>
<div class="line">        .indexType(IndexType::UInt16)</div>
<div class="line">        .vertexBuffer(<span class="keyword">sizeof</span>(<a class="code hl_struct" href="struct_vertex.html">Vertex</a>), 0)</div>
<div class="line">            .withAttribute(0, BufferFormat::XYZW32F, offsetof(<a class="code hl_struct" href="struct_vertex.html">Vertex</a>, position), AttributeSemantic::Position)</div>
<div class="line">            .withAttribute(1, BufferFormat::XYZW32F, offsetof(<a class="code hl_struct" href="struct_vertex.html">Vertex</a>, color), AttributeSemantic::Color)</div>
<div class="line">            .add();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Store the device and return,</span></div>
<div class="line">    m_device = device;</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">};</div>
<div class="ttc" id="aclass_lite_f_x_1_1_rendering_1_1_i_input_assembler_html_a5e652f2d535bcaeacf4fd24d7738064f"><div class="ttname"><a href="class_lite_f_x_1_1_rendering_1_1_i_input_assembler.html#a5e652f2d535bcaeacf4fd24d7738064f">LiteFX::Rendering::IInputAssembler::topology</a></div><div class="ttdeci">virtual PrimitiveTopology topology() const noexcept=0</div><div class="ttdoc">Returns the primitive topology.</div></div>
<div class="ttc" id="aclass_lite_f_x_1_1_rendering_1_1_input_assembler_html"><div class="ttname"><a href="class_lite_f_x_1_1_rendering_1_1_input_assembler.html">LiteFX::Rendering::InputAssembler</a></div><div class="ttdoc">Represents a the input assembler state of a RenderPipeline.</div><div class="ttdef"><b>Definition</b> rendering.hpp:506</div></div>
</div><!-- fragment --><p>Here we tell the GPU that we are providing it a list of triangles, which means that each triplet of vertices in the vertex buffer forms a new triangle. The indices of the vertices define the order of the corners of the triangle and thus the winding order in which the triangle is drawn. This order is important to decide if the triangle is facing towards or away from the camera. The indices themselves are stored in unsigned 16 bit integers. Finally, our vertex buffer contains vertices with two components, each containing 4 dimensional vectors. The first component refers to the position vector, the second to the vertex color.</p>
<p>Next we define the rasterizer state. Just like the input assembler, the rasterizer is part of the fixed-function pipeline and tells the GPU, how to generate fragments from the primitives that were output by the vertex shader invocations.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> startCallback = [<span class="keyword">this</span>]&lt;<span class="keyword">typename</span> TBackend&gt;(TBackend* backend) {</div>
<div class="line">    <span class="comment">// Alias type names for improved readability.</span></div>
<div class="line">    <span class="keyword">using </span><a class="code hl_class" href="class_lite_f_x_1_1_rendering_1_1_render_pass.html">RenderPass</a> = TBackend::render_pass_type;</div>
<div class="line">    <span class="keyword">using </span><a class="code hl_class" href="class_lite_f_x_1_1_rendering_1_1_frame_buffer.html">FrameBuffer</a> = TBackend::frame_buffer_type;</div>
<div class="line">    <span class="keyword">using </span><a class="code hl_class" href="class_lite_f_x_1_1_rendering_1_1_shader_program.html">ShaderProgram</a> = TBackend::shader_program_type;</div>
<div class="line">    <span class="keyword">using </span><a class="code hl_class" href="class_lite_f_x_1_1_rendering_1_1_input_assembler.html">InputAssembler</a> = TBackend::input_assembler_type;</div>
<div class="line">    <span class="keyword">using </span><a class="code hl_class" href="class_lite_f_x_1_1_rendering_1_1_rasterizer.html">Rasterizer</a> = TBackend::rasterizer_type;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create a render pass.</span></div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Create the frame buffer.</span></div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Find the proper file extension.</span></div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create the shader program.</span></div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Create input assembler state.</span></div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create rasterizer state.</span></div>
<div class="line">    <a class="code hl_typedef" href="namespace_lite_f_x.html#a58ddcdf7464eb219bb14d225153daa7f">SharedPtr&lt;Rasterizer&gt;</a> rasterizer = device-&gt;buildRasterizer()</div>
<div class="line">        .<a class="code hl_function" href="class_lite_f_x_1_1_rendering_1_1_rasterizer.html#ad767d6b3df0955f3e82144bd030cd284">polygonMode</a>(PolygonMode::Solid)</div>
<div class="line">        .cullMode(CullMode::BackFaces)</div>
<div class="line">        .cullOrder(CullOrder::CounterClockWise);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Store the device and return,</span></div>
<div class="line">    m_device = device;</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">};</div>
<div class="ttc" id="aclass_lite_f_x_1_1_rendering_1_1_rasterizer_html"><div class="ttname"><a href="class_lite_f_x_1_1_rendering_1_1_rasterizer.html">LiteFX::Rendering::Rasterizer</a></div><div class="ttdoc">Implements a IRasterizer.</div><div class="ttdef"><b>Definition</b> rendering_api.hpp:3371</div></div>
<div class="ttc" id="aclass_lite_f_x_1_1_rendering_1_1_rasterizer_html_ad767d6b3df0955f3e82144bd030cd284"><div class="ttname"><a href="class_lite_f_x_1_1_rendering_1_1_rasterizer.html#ad767d6b3df0955f3e82144bd030cd284">LiteFX::Rendering::Rasterizer::polygonMode</a></div><div class="ttdeci">PolygonMode polygonMode() const noexcept override</div><div class="ttdoc">Returns the polygon mode of the rasterizer state.The polygon mode of the rasterizer state.</div><div class="ttdef"><b>Definition</b> rasterizer.cpp:42</div></div>
</div><!-- fragment --><p>Here we tell the GPU to create a solid face from the vertices, so that the fragments inside the triangle are filled with color. We also set the cull mode to <code>BackFaces</code>, which causes back faces not to be drawn. As mentioned above, the front and back faces are defined by the winding order in the index buffer. We can declare which winding order defines a front-face using the <code>CullOrder</code>. Note that in our simple example, we will never actually get to see the back face, but for the sake of further expansion, we keep the setting enabled.</p>
<p>With all pipeline stages configured, we can now finally setup the actual render pipeline state. For the most part, we simply pass in the states created earlier here. However, one important aspect to note here, is that we actually need to describe where additional resources should be bound in the shader. We do this by providing a <em>pipeline layout</em>. A layout is required, even if (as in our case), we do not bind any additional resources! Fortunately, <a class="el" href="namespace_lite_f_x.html">LiteFX</a> supports shader reflection, which can create a pipeline layout from a shader program by calling <code>reflectPipelineLayout</code> on it.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> startCallback = [<span class="keyword">this</span>]&lt;<span class="keyword">typename</span> TBackend&gt;(TBackend* backend) {</div>
<div class="line">    <span class="comment">// Alias type names for improved readability.</span></div>
<div class="line">    <span class="keyword">using </span><a class="code hl_class" href="class_lite_f_x_1_1_rendering_1_1_render_pass.html">RenderPass</a> = TBackend::render_pass_type;</div>
<div class="line">    <span class="keyword">using </span><a class="code hl_class" href="class_lite_f_x_1_1_rendering_1_1_frame_buffer.html">FrameBuffer</a> = TBackend::frame_buffer_type;</div>
<div class="line">    <span class="keyword">using </span><a class="code hl_class" href="class_lite_f_x_1_1_rendering_1_1_shader_program.html">ShaderProgram</a> = TBackend::shader_program_type;</div>
<div class="line">    <span class="keyword">using </span><a class="code hl_class" href="class_lite_f_x_1_1_rendering_1_1_input_assembler.html">InputAssembler</a> = TBackend::input_assembler_type;</div>
<div class="line">    <span class="keyword">using </span><a class="code hl_class" href="class_lite_f_x_1_1_rendering_1_1_rasterizer.html">Rasterizer</a> = TBackend::rasterizer_type;</div>
<div class="line">    <span class="keyword">using </span><a class="code hl_class" href="class_lite_f_x_1_1_rendering_1_1_render_pipeline.html">RenderPipeline</a> = TBackend::render_pipeline_type;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create a render pass.</span></div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Create the frame buffer.</span></div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Find the proper file extension.</span></div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create the shader program.</span></div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Create input assembler state.</span></div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create rasterizer state.</span></div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create a render pipeline.</span></div>
<div class="line">    <a class="code hl_typedef" href="namespace_lite_f_x.html#a6daa7ddc3f560528522ba2849e09e3d3">UniquePtr&lt;RenderPipeline&gt;</a> renderPipeline = device-&gt;buildRenderPipeline(*renderPass, <span class="stringliteral">&quot;Geometry Pipeline&quot;</span>)</div>
<div class="line">        .<a class="code hl_function" href="class_lite_f_x_1_1_rendering_1_1_render_pipeline.html#afeaf0b565c256ec8ae9db97fa21b8809">inputAssembler</a>(inputAssembler)</div>
<div class="line">        .rasterizer(rasterizer)</div>
<div class="line">        .shaderProgram(shaderProgram)</div>
<div class="line">        .layout(shaderProgram-&gt;reflectPipelineLayout());</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Store the device and return,</span></div>
<div class="line">    m_device = device;</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">};</div>
<div class="ttc" id="aclass_lite_f_x_1_1_rendering_1_1_render_pipeline_html"><div class="ttname"><a href="class_lite_f_x_1_1_rendering_1_1_render_pipeline.html">LiteFX::Rendering::RenderPipeline</a></div><div class="ttdoc">Represents a graphics Pipeline.</div><div class="ttdef"><b>Definition</b> rendering.hpp:962</div></div>
<div class="ttc" id="aclass_lite_f_x_1_1_rendering_1_1_render_pipeline_html_afeaf0b565c256ec8ae9db97fa21b8809"><div class="ttname"><a href="class_lite_f_x_1_1_rendering_1_1_render_pipeline.html#afeaf0b565c256ec8ae9db97fa21b8809">LiteFX::Rendering::RenderPipeline::inputAssembler</a></div><div class="ttdeci">virtual SharedPtr&lt; input_assembler_type &gt; inputAssembler() const noexcept=0</div></div>
</div><!-- fragment --><blockquote class="doxtable">
<p>&zwj;Note that in a real-world application you might end up with lots of pipeline state objects. During rendering, switching between different pipeline states can be a costly operation. A good amount of performance potential when using modern graphics APIs is based on making those aspects of rendering explicit for the application. A good practice is to group draw calls by their pipeline state and to minimize the amount of pipelines required in order to minimize context switches. </p>
</blockquote>
<h2><a class="anchor" id="autotoc_md26"></a>
Managing state resources</h2>
<p>Now that we've setup all state resources (i.e., the pipeline state, render pass, and frame buffer), the startup callback will be left, which would cause them to be released immediately again. As we need them during rendering, we also need to think about where to store the state resources. One option is to store the resources in member variables inside our application class. Another option is to use the <em>device state</em> provided by the device we've created earlier. The device state can be accessed by calling the <code>state</code> method on the device. By handing over the state resources to the device state, we do not need to take care of managing their lifetimes. We can access the state resources later using the names we provided earlier. Note that we do not need to store the input assembler, rasterizer or shader program states, as those are stored by the pipeline state.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> startCallback = [<span class="keyword">this</span>]&lt;<span class="keyword">typename</span> TBackend&gt;(TBackend* backend) {</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create a render pipeline.</span></div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Store state resources in the device state.</span></div>
<div class="line">    device-&gt;state().add(std::move(renderPass));</div>
<div class="line">    device-&gt;state().add(std::move(renderPipeline));</div>
<div class="line">    std::ranges::for_each(frameBuffers, [device](<span class="keyword">auto</span>&amp; frameBuffer) { device-&gt;state().add(std::move(frameBuffer)); });</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Store the device and return,</span></div>
<div class="line">    m_device = device;</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">};</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md27"></a>
Buffer Transfers</h1>
<p>Currently the vertex and index buffers reside as member variables of our application instance in CPU memory. Before the GPU can access them, we need to transfer them. We do this by allocating a buffer for each of them before entering the applications main loop and transferring the data into the buffers. Those transfers are issued in a command buffer, which we record once and then let the driver execute it. As this is an asynchronous operation, we need to wait for its execution, before we can use the buffers. We do all of this in the application startup handler, just before entering the main loop.</p>
<p>In order to create the vertex and index buffers, we need to provide their layout, which we already defined earlier as part of the input assembler state. To acquire it, we can retrieve a reference of the pipeline from the device state. As there are different types of pipelines and only graphics pipelines require input assembler and rasterizer states, we need to upcast the reference to the appropriate interface to request the input assembler. We then use this input assembler state to create the vertex and index buffer instances and issue transfer commands to initialize them. Finally, we submit the command buffer and wait for it to be executed on the underlying command queue. After this point we can be sure that the resources are available for rendering.</p>
<div class="fragment"><div class="line"><span class="comment">// main.cpp</span></div>
<div class="line"><span class="keywordtype">void</span> SampleApp::onStartup()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Request the input assembler from the pipeline state.</span></div>
<div class="line">    <span class="keyword">auto</span>&amp; geometryPipeline = <span class="keyword">dynamic_cast&lt;</span><a class="code hl_class" href="class_lite_f_x_1_1_rendering_1_1_i_render_pipeline.html">IRenderPipeline</a>&amp;<span class="keyword">&gt;</span>(m_device-&gt;<a class="code hl_function" href="class_lite_f_x_1_1_rendering_1_1_i_graphics_device.html#ad2b6108f3139212ee25223dfb1a02c26">state</a>().pipeline(<span class="stringliteral">&quot;Geometry Pipeline&quot;</span>));</div>
<div class="line">    <span class="keyword">auto</span> inputAssembler = geometryPipeline.<a class="code hl_function" href="class_lite_f_x_1_1_rendering_1_1_i_render_pipeline.html#a5ecaf05af3771cfdb949ab74339c2056">inputAssembler</a>();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create a new command buffer from the transfer queue.</span></div>
<div class="line">    <span class="keyword">auto</span>&amp; transferQueue = m_device-&gt;<a class="code hl_function" href="class_lite_f_x_1_1_rendering_1_1_i_graphics_device.html#a7dc4937db403147d865d450b1bbc1b25">defaultQueue</a>(QueueType::Transfer);</div>
<div class="line">    <span class="keyword">auto</span> commandBuffer = transferQueue.<a class="code hl_function" href="class_lite_f_x_1_1_rendering_1_1_i_command_queue.html#a6f6f50abfd1f611a119fd6409ceb6b3c">createCommandBuffer</a>(<span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create the vertex buffer and transfer the staging buffer into it.</span></div>
<div class="line">    <span class="keyword">auto</span> vertexBuffer = m_device-&gt;<a class="code hl_function" href="class_lite_f_x_1_1_rendering_1_1_i_graphics_device.html#a277579408d637745fe6f1d428e7dc50d">factory</a>().<a class="code hl_function" href="class_lite_f_x_1_1_rendering_1_1_i_graphics_factory.html#a6c610808e48ba8292e603c9c87947418">createVertexBuffer</a>(<span class="stringliteral">&quot;Vertex Buffer&quot;</span>, inputAssembler-&gt;vertexBufferLayout(0), ResourceHeap::Resource, <span class="keyword">static_cast&lt;</span><a class="code hl_typedef" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a><span class="keyword">&gt;</span>(m_vertices.size()));</div>
<div class="line">    commandBuffer-&gt;transfer(m_vertices.data(), m_vertices.size() * <span class="keyword">sizeof</span>(<a class="code hl_struct" href="struct_vertex.html">::Vertex</a>), *vertexBuffer, 0, <span class="keyword">static_cast&lt;</span><a class="code hl_typedef" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a><span class="keyword">&gt;</span>(m_vertices.size()));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create the index buffer and transfer the staging buffer into it.</span></div>
<div class="line">    <span class="keyword">auto</span> indexBuffer = m_device-&gt;<a class="code hl_function" href="class_lite_f_x_1_1_rendering_1_1_i_graphics_device.html#a277579408d637745fe6f1d428e7dc50d">factory</a>().<a class="code hl_function" href="class_lite_f_x_1_1_rendering_1_1_i_graphics_factory.html#a295fc4fcd616491ea810d07c18e8d36f">createIndexBuffer</a>(<span class="stringliteral">&quot;Index Buffer&quot;</span>, *inputAssembler-&gt;indexBufferLayout(), ResourceHeap::Resource, <span class="keyword">static_cast&lt;</span><a class="code hl_typedef" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a><span class="keyword">&gt;</span>(m_indices.size()));</div>
<div class="line">    commandBuffer-&gt;transfer(m_indices.data(), m_indices.size() * inputAssembler-&gt;indexBufferLayout()-&gt;elementSize(), *indexBuffer, 0, <span class="keyword">static_cast&lt;</span><a class="code hl_typedef" href="namespace_lite_f_x_1_1_math.html#a9d0c69f488431cf242a743f5bee8065f">UInt32</a><span class="keyword">&gt;</span>(m_indices.size()));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Submit the command buffer and wait for its execution.</span></div>
<div class="line">    <span class="keyword">auto</span> fence = commandBuffer-&gt;submit();</div>
<div class="line">    transferQueue.waitFor(fence);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// This is the main application loop. Add any per-frame logic below.</span></div>
<div class="line">    <span class="keywordflow">while</span> (!::glfwWindowShouldClose(m_window.get()))</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Poll UI events.</span></div>
<div class="line">        ::glfwPollEvents();</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// ...</span></div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aclass_lite_f_x_1_1_rendering_1_1_i_command_queue_html_a6f6f50abfd1f611a119fd6409ceb6b3c"><div class="ttname"><a href="class_lite_f_x_1_1_rendering_1_1_i_command_queue.html#a6f6f50abfd1f611a119fd6409ceb6b3c">LiteFX::Rendering::ICommandQueue::createCommandBuffer</a></div><div class="ttdeci">SharedPtr&lt; ICommandBuffer &gt; createCommandBuffer(bool beginRecording=false, bool secondary=false) const</div><div class="ttdoc">Creates a command buffer that can be used to allocate commands on the queue.</div><div class="ttdef"><b>Definition</b> rendering_api.hpp:8619</div></div>
<div class="ttc" id="aclass_lite_f_x_1_1_rendering_1_1_i_graphics_device_html_a277579408d637745fe6f1d428e7dc50d"><div class="ttname"><a href="class_lite_f_x_1_1_rendering_1_1_i_graphics_device.html#a277579408d637745fe6f1d428e7dc50d">LiteFX::Rendering::IGraphicsDevice::factory</a></div><div class="ttdeci">virtual const IGraphicsFactory &amp; factory() const noexcept=0</div><div class="ttdoc">Returns the factory instance, used to create instances from the device.</div></div>
<div class="ttc" id="aclass_lite_f_x_1_1_rendering_1_1_i_graphics_device_html_a7dc4937db403147d865d450b1bbc1b25"><div class="ttname"><a href="class_lite_f_x_1_1_rendering_1_1_i_graphics_device.html#a7dc4937db403147d865d450b1bbc1b25">LiteFX::Rendering::IGraphicsDevice::defaultQueue</a></div><div class="ttdeci">const ICommandQueue &amp; defaultQueue(QueueType type) const</div><div class="ttdoc">Returns the instance of the default ICommandQueue that supports the combination of queue types specif...</div><div class="ttdef"><b>Definition</b> rendering_api.hpp:9225</div></div>
<div class="ttc" id="aclass_lite_f_x_1_1_rendering_1_1_i_graphics_device_html_ad2b6108f3139212ee25223dfb1a02c26"><div class="ttname"><a href="class_lite_f_x_1_1_rendering_1_1_i_graphics_device.html#ad2b6108f3139212ee25223dfb1a02c26">LiteFX::Rendering::IGraphicsDevice::state</a></div><div class="ttdeci">virtual DeviceState &amp; state() const noexcept=0</div><div class="ttdoc">Returns the device state that can be used to manage resources.</div></div>
<div class="ttc" id="aclass_lite_f_x_1_1_rendering_1_1_i_graphics_factory_html_a295fc4fcd616491ea810d07c18e8d36f"><div class="ttname"><a href="class_lite_f_x_1_1_rendering_1_1_i_graphics_factory.html#a295fc4fcd616491ea810d07c18e8d36f">LiteFX::Rendering::IGraphicsFactory::createIndexBuffer</a></div><div class="ttdeci">SharedPtr&lt; IIndexBuffer &gt; createIndexBuffer(const IIndexBufferLayout &amp;layout, ResourceHeap heap, UInt32 elements, ResourceUsage usage=ResourceUsage::Default) const</div><div class="ttdoc">Creates an index buffer, based on the layout .</div><div class="ttdef"><b>Definition</b> rendering_api.hpp:8921</div></div>
<div class="ttc" id="aclass_lite_f_x_1_1_rendering_1_1_i_graphics_factory_html_a6c610808e48ba8292e603c9c87947418"><div class="ttname"><a href="class_lite_f_x_1_1_rendering_1_1_i_graphics_factory.html#a6c610808e48ba8292e603c9c87947418">LiteFX::Rendering::IGraphicsFactory::createVertexBuffer</a></div><div class="ttdeci">SharedPtr&lt; IVertexBuffer &gt; createVertexBuffer(const IVertexBufferLayout &amp;layout, ResourceHeap heap, UInt32 elements=1, ResourceUsage usage=ResourceUsage::Default) const</div><div class="ttdoc">Creates a vertex buffer, based on the layout</div><div class="ttdef"><b>Definition</b> rendering_api.hpp:8886</div></div>
<div class="ttc" id="aclass_lite_f_x_1_1_rendering_1_1_i_render_pipeline_html"><div class="ttname"><a href="class_lite_f_x_1_1_rendering_1_1_i_render_pipeline.html">LiteFX::Rendering::IRenderPipeline</a></div><div class="ttdoc">The interface for a render pipeline.</div><div class="ttdef"><b>Definition</b> rendering_api.hpp:7541</div></div>
<div class="ttc" id="aclass_lite_f_x_1_1_rendering_1_1_i_render_pipeline_html_a5ecaf05af3771cfdb949ab74339c2056"><div class="ttname"><a href="class_lite_f_x_1_1_rendering_1_1_i_render_pipeline.html#a5ecaf05af3771cfdb949ab74339c2056">LiteFX::Rendering::IRenderPipeline::inputAssembler</a></div><div class="ttdeci">SharedPtr&lt; IInputAssembler &gt; inputAssembler() const noexcept</div><div class="ttdoc">Returns the input assembler state used by the render pipeline.</div><div class="ttdef"><b>Definition</b> rendering_api.hpp:7557</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md28"></a>
Frame Loop</h1>
<p>Finally, let's get to the actual rendering loop. The first thing we need to do is swap the back buffer on the swap chain. This operation returns us with an index into our frame buffer, indicating which frame we are going to write. Accordingly, we are retrieving the proper frame buffer instance from the device state. Also, we acquire the render pass, as we need it to execute the actual rendering logic in a moment.</p>
<div class="fragment"><div class="line"><span class="comment">// main.cpp</span></div>
<div class="line"><span class="keywordtype">void</span> SampleApp::onStartup()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// This is the main application loop. Add any per-frame logic below.</span></div>
<div class="line">    <span class="keywordflow">while</span> (!::glfwWindowShouldClose(m_window.get()))</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Poll UI events.</span></div>
<div class="line">        ::glfwPollEvents();</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Swap the back buffers for the next frame.</span></div>
<div class="line">        <span class="keyword">auto</span> backBuffer = m_device-&gt;<a class="code hl_function" href="class_lite_f_x_1_1_rendering_1_1_i_graphics_device.html#abcb9780dcce10b8e3c758cf70e304d10">swapChain</a>().<a class="code hl_function" href="class_lite_f_x_1_1_rendering_1_1_i_swap_chain.html#a362a8c6c7482ba266a2e1ee3bf42b413">swapBackBuffer</a>();</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Query state. For performance reasons, those state variables should be cached for more complex applications, instead of looking them up every frame.</span></div>
<div class="line">        <span class="keyword">auto</span>&amp; frameBuffer = m_device-&gt;<a class="code hl_function" href="class_lite_f_x_1_1_rendering_1_1_i_graphics_device.html#ad2b6108f3139212ee25223dfb1a02c26">state</a>().<a class="code hl_function" href="class_lite_f_x_1_1_rendering_1_1_device_state.html#ae5c9d1b10834c06ac2ba4f610121e179">frameBuffer</a>(std::format(<span class="stringliteral">&quot;Frame Buffer {0}&quot;</span>, backBuffer));</div>
<div class="line">        <span class="keyword">auto</span>&amp; renderPass = m_device-&gt;<a class="code hl_function" href="class_lite_f_x_1_1_rendering_1_1_i_graphics_device.html#ad2b6108f3139212ee25223dfb1a02c26">state</a>().<a class="code hl_function" href="class_lite_f_x_1_1_rendering_1_1_device_state.html#a9f500580bc3431317cfe95edd080359c">renderPass</a>(<span class="stringliteral">&quot;Geometry&quot;</span>);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// ...</span></div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aclass_lite_f_x_1_1_rendering_1_1_device_state_html_a9f500580bc3431317cfe95edd080359c"><div class="ttname"><a href="class_lite_f_x_1_1_rendering_1_1_device_state.html#a9f500580bc3431317cfe95edd080359c">LiteFX::Rendering::DeviceState::renderPass</a></div><div class="ttdeci">IRenderPass &amp; renderPass(const String &amp;id) const</div><div class="ttdoc">Returns a render pass from the device state.</div><div class="ttdef"><b>Definition</b> device_state.cpp:254</div></div>
<div class="ttc" id="aclass_lite_f_x_1_1_rendering_1_1_device_state_html_ae5c9d1b10834c06ac2ba4f610121e179"><div class="ttname"><a href="class_lite_f_x_1_1_rendering_1_1_device_state.html#ae5c9d1b10834c06ac2ba4f610121e179">LiteFX::Rendering::DeviceState::frameBuffer</a></div><div class="ttdeci">IFrameBuffer &amp; frameBuffer(const String &amp;id) const</div><div class="ttdoc">Returns a frame buffer from the device state.</div><div class="ttdef"><b>Definition</b> device_state.cpp:262</div></div>
<div class="ttc" id="aclass_lite_f_x_1_1_rendering_1_1_i_graphics_device_html_abcb9780dcce10b8e3c758cf70e304d10"><div class="ttname"><a href="class_lite_f_x_1_1_rendering_1_1_i_graphics_device.html#abcb9780dcce10b8e3c758cf70e304d10">LiteFX::Rendering::IGraphicsDevice::swapChain</a></div><div class="ttdeci">virtual const ISwapChain &amp; swapChain() const noexcept=0</div><div class="ttdoc">Returns the swap chain, that contains the back and front buffers used for presentation.</div></div>
<div class="ttc" id="aclass_lite_f_x_1_1_rendering_1_1_i_swap_chain_html_a362a8c6c7482ba266a2e1ee3bf42b413"><div class="ttname"><a href="class_lite_f_x_1_1_rendering_1_1_i_swap_chain.html#a362a8c6c7482ba266a2e1ee3bf42b413">LiteFX::Rendering::ISwapChain::swapBackBuffer</a></div><div class="ttdeci">virtual UInt32 swapBackBuffer() const =0</div><div class="ttdoc">Swaps the front buffer with the next back buffer in order.</div></div>
</div><!-- fragment --><p>A render pass needs to be started by passing the frame buffer into it. Remember how we setup a render target and mapped it to the frame buffer during setup? This way, the render pass can now tell which image to draw into while it executes. The render pass also provides us with a command buffer, we can record all drawing commands into. The advantage of using this command buffer is, that it already sets up synchronization for us. In multi-threaded applications, we can also have multiple command buffers per render pass - one for each thread that should record commands.</p>
<p>Within the command buffer, we setup the pipeline state, telling the GPU how to draw the object (as explained during the setup). We also set the viewport and scissor region we declared earlier. Next, we bind the vertex and index buffer for our geometry and call <code>drawIndexed</code> to invoke the actual rendering. Finally, ending the render pass submits the command buffer and issues the present command on the swap chain.</p>
<div class="fragment"><div class="line"><span class="comment">// main.cpp</span></div>
<div class="line"><span class="keywordtype">void</span> SampleApp::onStartup()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// This is the main application loop. Add any per-frame logic below.</span></div>
<div class="line">    <span class="keywordflow">while</span> (!::glfwWindowShouldClose(m_window.get()))</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Begin rendering on the render pass and use the only pipeline we&#39;ve created for it.</span></div>
<div class="line">        renderPass.begin(frameBuffer);</div>
<div class="line">        <span class="keyword">auto</span> commandBuffer = renderPass.commandBuffer(0);</div>
<div class="line">        commandBuffer-&gt;use(geometryPipeline);</div>
<div class="line">        commandBuffer-&gt;setViewports(m_viewport.get());</div>
<div class="line">        commandBuffer-&gt;setScissors(m_scissor.get());</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Bind the vertex and index buffers.</span></div>
<div class="line">        commandBuffer-&gt;bind(*vertexBuffer);</div>
<div class="line">        commandBuffer-&gt;bind(*indexBuffer);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Draw the object and present the frame by ending the render pass.</span></div>
<div class="line">        commandBuffer-&gt;drawIndexed(indexBuffer-&gt;elements());</div>
<div class="line">        renderPass.end();</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>With everything set up and running, we can now execute the program and should see a single triangle in the top-right corner of the window. Feel free to experiment with the vertices and indices to change the shape of the triangle, but take care of the index order or the triangle might be culled!</p>
<h1><a class="anchor" id="autotoc_md29"></a>
Final Words</h1>
<p>This bare-bones tutorial should serve as a quick guide on how to get started working with the engine. For a more elaborate example, consult the samples from the <a href="https://github.com/crud89/LiteFX/tree/main/src/Samples">engine sources</a> or <a href="https://github.com/crud89/LiteFX-Sample">this standalone sample</a>. If you want to quick-start your application, you can use the <a href="https://github.com/crud89/LiteFX-Template">project template</a>. This sets up all the bare-bones infrastructure required to start working with the engine, but it does not provide any code for drawing yet. The full source code for this tutorial can be found <a href="https://github.com/crud89/LiteFX-Tutorial">in this repository</a>. If you have further questions feel free to join our <a href="https://github.com/crud89/LiteFX/discussions">discussions</a> or open an <a href="https://github.com/crud89/LiteFX/issues">issue</a> if you encounter any problems. If you want to contribute to the project, feel free to open a <a href="https://github.com/crud89/LiteFX/pulls">pull request</a>. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
